
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>TBD - In Pursuit of Laziness</title>
  <meta name="author" content="Manish Goregaokar">

  
  <meta name="description" content="Last year I worked on the Stylo project, uplifting Servo&rsquo;s CSS engine (&ldquo;style system&rdquo;) into Firefox&rsquo;s browser engine
(&ldquo; &hellip;">
  
  <!-- Tweaked https://harimenon.com/blog/2013/02/23/twitter-cards-for-octopress-blogs/ -->
  
      <meta property="twitter:card" content="summary">
      <meta property="twitter:site" content="Manishearth">
      <meta property="twitter:url" content="http://manishearth.github.io">
      <meta property="twitter:title" content="TBD">
      <meta property="twitter:description" content="Last year I worked on the Stylo project, uplifting Servo&rsquo;s CSS engine (&ldquo;style system&rdquo;) into Firefox&rsquo;s browser engine
(&ldquo;Gecko&rdquo;). This involved a lot of gnarly FFI &hellip;">
      <meta name="twitter:image" content="http://manishearth.github.io/images/me.png" />
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://manishearth.github.io/drafts/ffi.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="In Pursuit of Laziness" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/manish.js" type="text/javascript"></script>
  <!--- MathJax Configuration -->
  
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-62537162-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">In Pursuit of Laziness</a></h1>
  
    <h2>Manish Goregaokar&#8217;s blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="manishearth.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">TBD</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-09-29T00:00:00+00:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2018</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Last year I worked on the <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">Stylo</a> project, uplifting Servo&rsquo;s CSS engine (&ldquo;style system&rdquo;) into Firefox&rsquo;s browser engine
(&ldquo;Gecko&rdquo;). This involved a <em>lot</em> of gnarly FFI between Servo&rsquo;s Rust codebase and Firefox&rsquo;s C++ codebase. There were a
lot of challenges in doing this, and I feel like it&rsquo;s worth sharing things from our experiences.</p>

<p>If you&rsquo;re interested in Rust integrations, you may find <a href="https://www.youtube.com/watch?v=_CdQHfLhmvI">this talk by Isis and Chelsea on integrating Rust in Tor</a>, <a href="https://www.youtube.com/watch?v=x9acx2zgx4Q">this talk by Katharina on Rust - C++ FFI</a>, and <a href="https://hsivonen.fi/modern-cpp-in-rust/">this blog post by Henri on integrating encoding-rs into Firefox</a> useful as well.</p>

<h2>Who is this post for?</h2>

<p>So, first off the bat, I&rsquo;ll mention that when integrating Rust into a C++ codebase, you
want to <em>avoid</em> having integrations as tight as Stylo. Don&rsquo;t do what we did; make your Rust
component mostly self-contained so that you just have to maintain something like ten FFI functions
for interacting with it.</p>

<p>That said, sometimes you <em>have</em> to have gnarly integrations, and this blog post is for those use cases.
These techniques mostly use bindgen for implementation, however you can potentially use them with hand-rolled bindings as well.</p>

<h2>What was involved in Stylo&rsquo;s FFI?</h2>

<p>So, what made Stylo&rsquo;s FFI so complicated?</p>

<p>It turns out that browsers are quite monolithic. You can split them into vaguely-defined components, but
these components are still tightly integrated. If you intend to replace a component, you may need to
make a jagged edge of an integration surface.</p>

<p>The style system is more self-contained than other parts, but it&rsquo;s still quite tightly integrated.</p>

<p>The main job of a &ldquo;style system&rdquo; is to take the CSS rules and DOM tree, and run them through &ldquo;the cascade&rdquo;
with an output of &ldquo;computed styles&rdquo; tagged on each node in the tree. So, for example, it will take a document like
the following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;style </span><span class="na">type=</span><span class="s">&quot;text/css&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">body</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">font-size</span><span class="o">:</span> <span class="m">12px</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nt">div</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">height</span><span class="o">:</span> <span class="m">2em</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="nt">&lt;/style&gt;</span>
</span><span class='line'><span class="nt">&lt;body&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">foo</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>and turn it into something like:</p>

<ul>
<li><code>&lt;body&gt;</code> has a <code>font-size</code> of <code>12px</code>, everything else is the default</li>
<li>the <code>div</code> <code>#foo</code> has a computed <code>height</code> of <code>24px</code>, everything else is the default</li>
</ul>


<p>From a code point of view, this means that Stylo takes in Gecko&rsquo;s C++ DOM tree. It parses all the CSS,
and then runs the cascade on the tree. It stores computed styles on each element in a way that Gecko can read
very cheaply.</p>

<p>Style computation can involve some complex steps that require calling back into C++ code. Servo&rsquo;s style system
is multithreaded, but Gecko is mostly designed to work off of a single main thread per process, so we need to
deal with this impedence mismatch.</p>

<p>Since the output of Stylo is C++-readable structs, Stylo needs to be able to read and write nontrivial C++
abstractions. Typical FFI involves passing values over a boundary, never to be seen again, however here we&rsquo;re
dealing with persistent state that is accessed by both sides. At best you may have some persistent rust structs
that C++ code may hold onto as opaque pointers, and manipulating them via FFI.</p>

<p>To sum up, we have:</p>

<ul>
<li>Lots and lots of back-and-forth FFI</li>
<li>Thread safety concerns</li>
<li>Rust code regularly dealing with nontrivial C++ abstractions</li>
<li>A need for nontrivial abstractions to be passed over FFI</li>
</ul>


<p>All of this conspires to make for some complicated FFI code :)</p>

<h1>The actual techniques</h1>

<p>Alright, on to the actual techniques.</p>

<p>I&rsquo;ll try to structure this so that the more broadly useful (and/or less gnarly) techniques come earlier in the post.</p>

<h2>Basic bindgen</h2>

<p><a href="https://github.com/rust-lang-nursery/rust-bindgen/">Bindgen</a> is a tool that generates Rust bindings for structs and functions from the provided C or C++ header files. It&rsquo;s often used for writing Rust bindings to existing C/C++ libraries, however it&rsquo;s useful for integrations as well.</p>

<p>To use it for an integration, write a header file containing the functions your Rust code needs (referencing structs from other header files if necessary), and <a href="https://rust-lang-nursery.github.io/rust-bindgen/command-line-usage.html">run bindgen on it</a>. For some codebases, doing this once and
checking in the generate file suffices, but if your C++ code is going to change a lot, <a href="https://rust-lang-nursery.github.io/rust-bindgen/tutorial-1.html">run it as a build dependency instead</a>. Beware that this can adversely impact build times, since your Rust build now has a partial
C++ compilation step.</p>

<p>For large C++ codebases, pulling in a single header will likely pull in a <em>lot</em> of stuff. You should <a href="https://rust-lang-nursery.github.io/rust-bindgen/whitelisting.html">whitelist</a>, <a href="https://rust-lang-nursery.github.io/rust-bindgen/blacklisting.html">blacklist</a>, and/or mark things as <a href="https://rust-lang-nursery.github.io/rust-bindgen/opaque.html">opaque</a> to reduce the amount of bindings generated. It&rsquo;s best to go the whitelisting route &mdash; give bindgen a whitelisted list of functions / structs to generate bindings for, and it will transitively generate bindings for any dependencies they may have. Sometimes even this will end up generating a lot, it&rsquo;s sometimes worth finding structs you&rsquo;re not using and marking them as opaque so that their bindings aren&rsquo;t necessary. Marking something as opaque replaces it with an array of the appropriate size and alignment, so from the Rust side it&rsquo;s just some bits you don&rsquo;t care about.</p>

<p>Bindgen <a href="https://rust-lang-nursery.github.io/rust-bindgen/cpp.html"><em>does</em> support some C++ features</a> (you may need to pass <code>-x c++</code>). This is pretty good for generating bindings to e.g. templated structs. However, it&rsquo;s not possible to support <em>all</em> C++ features here, so you may need to blacklist, opaqueify, or use intermediate types if you have some complicated C++ abstractions in the deps. You&rsquo;ll typically get an error when generating bindings or when compiling the generated bindings, so don&rsquo;t worry about this unless that happens.</p>

<p>Bindgen is <em>quite</em> configurable. Stylo has a <a href="https://searchfox.org/mozilla-central/rev/819cd31a93fd50b7167979607371878c4d6f18e8/servo/components/style/build_gecko.rs">script</a> that consumes a <a href="https://searchfox.org/mozilla-central/source/layout/style/ServoBindings.toml">large toml file</a> containing all of the configuration.</p>

<h2>cbindgen</h2>

<p>We don&rsquo;t use <a href="https://github.com/eqrion/cbindgen">cbindgen</a> in Stylo, but it&rsquo;s <a href="https://searchfox.org/mozilla-central/source/gfx/webrender_bindings/webrender_ffi_generated.h">used for Webrender</a>. It does the inverse of what bindgen does: given a Rust crate, it generates C headers for its public API. It&rsquo;s also quite configurable, however I&rsquo;ve not used it much so I don&rsquo;t have many tips for it. I thought it&rsquo;s worth mentioning either way.</p>

<h2>Bindgen-aided C++ calling Rust</h2>

<p>So bindgen helps with creating things for Rust to call and manipulate, but not in the opposite direction. cbindgen can help here, but I&rsquo;m not sure if it&rsquo;s advisable to have <em>both</em> bindgen and cbindgen operating on the same codebase.</p>

<p>In Stylo we use a bit of a hack for this. Firstly, all FFI functions defined in C++ that Rust calls are declared in <a href="https://searchfox.org/mozilla-central/rev/819cd31a93fd50b7167979607371878c4d6f18e8/layout/style/ServoBindingList.h">one file</a>, and are all named <code>Gecko_*</code>. Bindgen supports regexes for things like whitelisting, so this naming scheme makes it easy to deal with.</p>

<p>We also declare the FFI functions defined in Rust that C++ calls in <a href="https://searchfox.org/mozilla-central/rev/819cd31a93fd50b7167979607371878c4d6f18e8/layout/style/ServoBindingList.h">another file</a>, named <code>Servo_*</code>. They&rsquo;re also all <a href="https://searchfox.org/mozilla-central/rev/819cd31a93fd50b7167979607371878c4d6f18e8/servo/ports/geckolib/glue.rs">defined in one place</a></p>

<p>However, there&rsquo;s nothing ensuring that the signatures match! If we&rsquo;re not careful, there may be mismatches. We use a small <a href="https://searchfox.org/mozilla-central/rev/819cd31a93fd50b7167979607371878c4d6f18e8/servo/ports/geckolib/tests/servo_function_signatures.rs">autogenerated</a> to ensure the validity of the signatures.</p>

<p>This is especially important as we do things like type replacement, and we need tests to ensure that the rug isn&rsquo;t pulled out from underneath us.</p>

<h2>Type replacing for fun and profit</h2>

<p>Using <a href="https://rust-lang-nursery.github.io/rust-bindgen/blacklisting.html">blacklisting</a> in conjunction with the <code>--raw-line</code>/<code>raw_line()</code> flag, one can effectively ask bindgen to &ldquo;replace&rdquo; types. Blacklisting asks bindgen not to generate bindings for a type, however bindgen will continue to generate bindings referring to that type if necessary. (Unlike opaque types where bindgen generates an opaque binding for the type). <code>--raw-line</code> lets you request bindgen to add a line of raw rust code to the file,
and such a line can potentially define or import a new version of the type you blacklisted. Effectively, this lets
you replace types.</p>

<p>Bindgen generates unit tests ensuring that the layout of your structs is correct (run them!), so if you accidentally replace a type with something incompatible, you will get warnings at the struct level (functions may not warn).</p>

<p>There are various ways this can be used:</p>

<h3>Safe references across FFI</h3>

<p>Calling into C++ (and accepting data from C++) is unsafe. However, there&rsquo;s no reason we should have to worry about this more than we have to. For example, it would be nice if accessor FFI functions (take a foreign object, return something from inside it) could use lifetimes. And if nullability were represented on the FFI boundary so that you
don&rsquo;t miss null checks (and can assume non-nullness when the C++ API is okay with it).</p>

<p>In Stylo, we have lots of functions like the following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">RawGeckoNodeBorrowedOrNull</span> <span class="nf">Gecko_GetLastChild</span><span class="p">(</span><span class="n">RawGeckoNodeBorrowed</span> <span class="n">node</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>which bindgen translates to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">Gecko_GetLastChild</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">RawGeckoNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">RawGeckoNode</span><span class="o">&gt;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using the <a href="https://searchfox.org/mozilla-central/rev/819cd31a93fd50b7167979607371878c4d6f18e8/servo/components/style/build_gecko.rs">bindgen build script</a> on a provided <a href="https://searchfox.org/mozilla-central/rev/819cd31a93fd50b7167979607371878c4d6f18e8/layout/style/ServoBindings.toml#648-671">list of borrow-able types</a>, we&rsquo;ve told bindgen that:</p>

<ul>
<li><code>FooBorrowedOrNull</code> is actually <code>Option&lt;&amp;Foo&gt;</code></li>
<li><code>FooBorrowed</code> is actually <code>&amp;Foo</code></li>
</ul>


<p><code>Option&lt;&amp;Foo&gt;</code> <a href="https://doc.rust-lang.org/nomicon/repr-rust.html">is represented as a single nullable pointer in Rust</a>, so this is a clean translation.
We&rsquo;re forced to null-check it, but once we do we can safely assume that the reference is valid. Furthermore, due to lifetime elision the actual signature of the FFI function is <code>fn Gecko_GetLastChild&lt;'a&gt;(x: &amp;'a RawGeckoNode) -&gt; Option&lt;&amp;'a RawGeckoNode&gt;</code>, which ensures we won&rsquo;t let the returned reference outlive the passed reference.</p>

<p>Note that this is shifting some of the safety invariants to the C++ side: We rely on the C++ to pass us valid references, and we rely on it to not pass nulls when not marked as such. Most C++ codebases internally rely on such invariants for safety anyway, so this isn&rsquo;t much of a stretch.</p>

<p>We do this on both sides, actually: Many of our Rust-defined <code>extern "C"</code> functions that C++ calls get to be safe because the types let us assume the validity of the pointers obtaned from C++.</p>

<h3>Making C++ abstractions Rust-accessible</h3>

<p>A very useful thing to do here is to replace various C++ abstractions with Rust versions of them that share semantics. In Gecko, most strings are stored in <code>nsString</code>/<code>nsAString</code>/etc.</p>

<p>We&rsquo;ve written an <a href="https://searchfox.org/mozilla-central/rev/6ddb5fb144993fb5de044e2e8d900d7643b98a4d/servo/support/gecko/nsstring/src/lib.rs">nsstring</a> crate that represents layout-compatible <code>nsString</code>s in a more Rusty way, with Rusty APIs. We then ask bindgen to replace Gecko <code>nsString</code>s with these.</p>

<p>Usually it&rsquo;s easier to just write an impl for the bindgen-generated abstraction, however sometimes you must replace it:</p>

<ul>
<li>When the abstraction internally does a lot of template stuff not supported by bindgen</li>
<li>When you want the code for the abstraction to be in a separate crate</li>
</ul>


<h2>Potential pitfall: Passing C++ classes by-value over FFI</h2>

<p>It&rsquo;s quite tempting to do stuff like</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">Servo_Gimme</span><span class="p">(...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>where you pass complicated classes by-value over FFI (<code>RefPtr</code> is Gecko&rsquo;s variant of <code>Rc&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code>).</p>

<p>This works on some systems, but is broken on MSVC:
<a href="https://github.com/rust-lang/rust/issues/38258">The ABI for passing non-POD types through functions is different</a>. The linker usually notices this and complains, but it&rsquo;s worth avoiding this entirely.</p>

<p>In Stylo we handle this by using some macro-generated intermediate types which are basically the same thing as the original class but without any constructors/destructors/operators. We convert to/from these types immediately before/after the FFI call, and on the Rust side we do similar conversions to Rust-compatible abstractions.</p>

<h2>Sharing abstractions with destructors</h2>

<p>If you&rsquo;re passing ownership of abstractions across FFI, you probably want for Rust code to be able to destroy C++ objects, and vice versa.</p>

<p>One way of doing this is to implement <code>Drop</code> on the generated struct. If you have <code>class MyString</code>, you can do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">MyString</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="o">~</span><span class="n">MyString</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">MyString_Destroy</span><span class="p">(</span><span class="o">*</span><span class="n">MyString</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">x</span><span class="o">-&gt;~</span><span class="n">MyString</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">bindings</span><span class="o">::</span><span class="n">MyString</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="nb">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// (bindgen only)</span>
</span><span class='line'>        <span class="n">bindings</span><span class="o">::</span><span class="n">MyString</span><span class="o">::</span><span class="n">destruct</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span class='line'>        <span class="c1">// OR</span>
</span><span class='line'>        <span class="n">bindings</span><span class="o">::</span><span class="n">MyString_Destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>MyString_Destroy</code> isn&rsquo;t necessary with bindgen &ndash; bindgen will generate a <code>MyString::destruct()</code> function for you &ndash; but be careful, this will make your generated bindings very platform-specific, so be sure to only do this if running them at build time.</p>

<p>In Stylo we went down the route of manually defining <code>_Destroy()</code> functions since we started off with checked-in platform-agnostic bindings, however we could probably switch to using <code>destruct()</code> if we want to now.</p>

<p>When it comes to generic types, it&rsquo;s a bit trickier, since <code>Drop</code> can&rsquo;t be implemented piecewise. You have to do something like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyVector</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">MyVector_Deallocate_Buffer</span><span class="p">(</span><span class="n">MyVector</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// assume we have an implementation of Iterator for MyVector&lt;T&gt; somewhere</span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">bindings</span><span class="o">::</span><span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fn</span> <span class="nb">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// calls the destructor for `v`, if any</span>
</span><span class='line'>            <span class="n">std</span><span class="o">::</span><span class="n">ptr</span><span class="o">::</span><span class="n">drop_in_place</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">bindings</span><span class="o">::</span><span class="n">MyVector_Deallocate_Buffer</span><span class="p">(</span><span class="bp">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">c_void</span><span class="o">&gt;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that if you forget to add a <code>Drop</code> implementation for <code>T</code>, this won&rsquo;t work. See <a href="#mirror-types">the next section</a> for some ways to handle this by creating a &ldquo;safe&rdquo; mirror type.</p>

<h2>Mirror types</h2>

<p>C++ libraries often have useful templated abstractions, and it&rsquo;s nice to be able to manipulate them from Rust. Sometimes, it&rsquo;s possible to just tack on semantics on the Rust side (either by adding an implementation or by doing type replacement), but in some cases this is tricky.</p>

<p>For example, Gecko has <code>RefPtr&lt;T&gt;</code>, which is similar to <code>Rc&lt;T&gt;</code>, except the actual refcounting logic is up to <code>T</code> to implement (it can choose between threadsafe, non-threadsafe, etc), which it does by writing <code>AddRef()</code> and <code>Release()</code> methods.</p>

<p>We mirror this in Rust by having a trait:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c-Doc">/// Trait for all objects that have Addref() and Release</span>
</span><span class='line'><span class="c-Doc">/// methods and can be placed inside RefPtr&lt;T&gt;</span>
</span><span class='line'><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">trait</span> <span class="n">RefCounted</span> <span class="p">{</span>
</span><span class='line'>    <span class="c-Doc">/// Bump the reference count.</span>
</span><span class='line'>    <span class="k">fn</span> <span class="n">addref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span>
</span><span class='line'>    <span class="c-Doc">/// Decrease the reference count.</span>
</span><span class='line'>    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c-Doc">/// A custom RefPtr implementation to take into account Drop semantics and</span>
</span><span class='line'><span class="c-Doc">/// a bit less-painful memory management.</span>
</span><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">RefCounted</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ptr</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
</span><span class='line'>    <span class="n">_marker</span><span class="o">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We implement the <code>RefCounted</code> trait for C++ types that are wrapped in <code>RefPtr</code> which we wish to access through Rust. We have <a href="https://searchfox.org/mozilla-central/rev/cfaa5a1d48d6bc6552199e73004ecb05d0a9c921/servo/components/style/gecko_bindings/sugar/refptr.rs#258-315">some</a> <a href="https://searchfox.org/mozilla-central/rev/cfaa5a1d48d6bc6552199e73004ecb05d0a9c921/layout/style/GeckoBindings.h#52-60">macros</a> that make this easier to do. We have to have such a trait, because otherwise Rust code wouldn&rsquo;t know how to manage various C++ types.</p>

<p>However, <code>RefPtr&lt;T&gt;</code> here can&rsquo;t be the type that ends up being used in bindgen. Rust doesnt let us do things like <code>impl&lt;T: RefCounted&gt; Drop for RefPtr&lt;T&gt;</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, so we can&rsquo;t effectively make this work with the bindgen generated type unless we write a <code>RefCounted</code> implementation for every refcounted type that shows up in the bindgen output at all &ndash; which would be a lot of work.</p>

<p>Instead, we let bindgen generate its own <code>RefPtr&lt;T&gt;</code>, called <code>structs::RefPtr&lt;T&gt;</code> (all the structs that bindgen generates for Gecko go in a <code>structs::</code> module). <code>structs::RefPtr&lt;T&gt;</code> itself doesn&rsquo;t have enough semantics to be something we can pass around willy-nilly in Rust code without causing leaks. However, it has <a href="https://searchfox.org/mozilla-central/rev/cfaa5a1d48d6bc6552199e73004ecb05d0a9c921/servo/components/style/gecko_bindings/sugar/refptr.rs#150-234">some methods</a> that allow for conversion into the &ldquo;safe&rdquo; mirror <code>RefPtr&lt;T&gt;</code> (but only if <code>T: RefCounted</code>). So if you need to manipulate a <code>RefPtr&lt;T&gt;</code> in a C++ struct somewhere, you immediately use one of the conversion methods to get a safe version of it first, and <em>then</em> do things to it. Refcounted types that don&rsquo;t have the <code>RefCounted</code> implementation won&rsquo;t have conversion methods: they may exist in the data you&rsquo;re manipulating, however you won&rsquo;t be able to work with them.</p>

<p>In general, whenever attaching extra semantics to generic bindgen types doesn&rsquo;t work, an alternative is to create a mirror type that&rsquo;s completely safe to use from Rust, with a trait that gates conversion to the mirror type.</p>

<h2>Potential pitfall: Allocators</h2>

<p>If you&rsquo;re passing heap-managed abstractions across FFI, be careful about which code frees which objects. If your Rust
and C++ code don&rsquo;t share allocators, deallocating memory allocated on the other side can have disastrous consequences.</p>

<p>If you&rsquo;re building a cdylib or staticlib with Rust (this is likely if you&rsquo;re linking it with a C++ application), the compiler will by default pick the system allocator (<code>malloc</code>), so if your C++ application also uses the same you&rsquo;re all set.</p>

<p>On some platforms when building rlibs and binaries, Rust may choose jemalloc instead. It&rsquo;s also possible that your C++ code uses a different allocator (lots of applications use allocators like jemalloc or tcmalloc, some have their own custom allocators like <code>tor_malloc</code> in Tor).</p>

<p>In such cases you have one of three options:</p>

<ul>
<li>Avoid transferring ownership of heap-allocated items, only share things as borrowed references</li>
<li>Call destructors over FFI, as detailed in <a href="#sharing-abstractions-with-destructors">the section on destructors above</a></li>
<li>Set Rust&rsquo;s allocator to be the same as documented <a href="https://doc.rust-lang.org/nightly/std/alloc/#the-global_allocator-attribute">in the <code>std::alloc</code> module</a>. Basically, can use the <code>#[global_allocator]</code> attribute to select which allocator you wish to use, and if necessary you can implement the <code>GlobalAlloc</code> trait on a custom allocator type that calls into whatever custom allocator C++ is using.</li>
</ul>


<h2>Crazy stuff</h2>

<p>@@</p>

<p>@@ Transparent</p>

<p>@@ C enums</p>

<p>@@ ABI concerns</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><code>Drop</code> impls are restricted in a bunch of ways for safety, in particular you cannot write <code>impl&lt;T: RefCounted&gt; Drop for RefPtr&lt;T&gt;</code> unless <code>RefPtr</code> is defined as <code>RefPtr&lt;T: RefCounted&gt;</code>. It&rsquo;s not possible to have a generic type that has an impl of <code>Drop</code> for only <em>some</em> possible instantiations of its generics.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard beforesep">Posted by <span class="fn">Manish Goregaokar</span></span>

      




<time class='entry-date' datetime='2018-09-29T00:00:00+00:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2018</span></span> <span class='time'>12:00 am</span></time>
      

    



<span class="categories aftersep">
  
    <a class='category' href='/blog/categories/c-plus-plus/'>c++</a>, <a class='category' href='/blog/categories/programming/'>programming</a>, <a class='category' href='/blog/categories/rust/'>rust</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://manishearth.github.io/drafts/ffi.html" data-via="Manishearth" data-counturl="http://manishearth.github.io/drafts/ffi.html" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
<h1> About Me </h1>
<div id="about">
    I&#8217;m a research engineer at Mozilla working on the <a href="http://github.com/servo/servo">Servo browser engine</a>
</div>
<div id="doodads">
 <a href="http://twitter.com/Manishearth" style="white-space:normal">   <img style="border:none;box-shadow:none" src="/images/twitter.png" width="30px"></a>
 <a href="http://github.com/Manishearth" style="white-space:normal">   <img style="border:none;box-shadow:none"  src="/images/github.png" width="30px"></a>
</div>
</section>
<section>
<iframe scrolling="no" style="border: 0; height: 58px; width: 208px; overflow: hidden;" src="https://se-flair.appspot.com/751483b5-3bd0-467a-b3aa-f0bb8ac3887d/"></iframe>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2019/10/09/on-voting-systems/">On Voting Systems</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/02/04/rust-governance-scaling-empathy/">Rust Governance: Scaling Empathy</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/09/11/converting-a-webgl-application-to-webvr/">Converting a WebGL Application to WebVR</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/08/26/why-i-enjoy-blogging/">Why I Enjoy Blogging</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/06/05/the-future-of-clippy-the-rust-linter/">The Future of Clippy</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - Manish Goregaokar - Licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY SA 4.0</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
