<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | In Pursuit of Laziness]]></title>
  <link href="http://manishearth.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://manishearth.github.io/"/>
  <updated>2016-03-05T08:49:04+05:30</updated>
  <id>http://manishearth.github.io/</id>
  <author>
    <name><![CDATA[Manish Goregaokar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Designing a GC in Rust]]></title>
    <link href="http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/"/>
    <updated>2015-09-01T00:23:40+05:30</updated>
    <id>http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust</id>
    <content type="html"><![CDATA[<p>For a while I&rsquo;ve been working on a <a href="http://github.com/Manishearth/rust-gc/">garbage collector for Rust</a> with <a href="http://github.com/mystor">Michael
Layzell</a>. I thought this would be a good time to talk of our design and progress so far.</p>

<h1>Motivation</h1>

<p>&ldquo;Wait&rdquo;, you ask, &ldquo;why does Rust need a garbage collector&rdquo;? Rust is supposed to work <em>without</em> a GC,
that&rsquo;s one of its main selling points!</p>

<p>True. Rust <em>does</em> work pretty well without a GC. It&rsquo;s managed to do without one so far, and we still
have all sorts of well-written crates out there (none of which use a GC).</p>

<p>But Rust is not just about low-cost memory safety. It&rsquo;s also <a href="http://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">about choosing your costs and
guarantees</a>. <code>Box&lt;T&gt;</code> and stack allocation are not always sufficient, sometimes one needs to
reach for something like <code>Rc&lt;T&gt;</code> (reference counting). But even <code>Rc</code> is not perfect; it can&rsquo;t handle
cycles between pointers. There are solutions to that issue like using <code>Weak&lt;T&gt;</code>, but that only works
in limited cases (when you know what the points-to graph looks like at compile time), and isn&rsquo;t very
ergonomic.</p>

<p>Cases where one needs to maintain a complicated, dynamic graph are where a GC becomes useful.
Similarly, if one is writing an interpreter for a GCd language, having a GC in Rust would simplify
things a lot.</p>

<p>Not to say that one should pervasively use a GC in Rust. Similar to <code>Rc&lt;T&gt;</code>, it&rsquo;s best to use
regular ownership-based memory management as much as possible, and sprinkle <code>Rc</code>/<code>Gc</code> in places
where your code needs it.</p>

<h1>Previous designs</h1>

<p>This isn&rsquo;t the first GC in Rust. Automatic memory management has existed before in various forms,
but all were limited.</p>

<p>Besides the ones listed below, Nick Fitzgerald&rsquo;s <a href="https://github.com/fitzgen/bacon-rajan-cc">cycle collector</a> based on <a href="researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf">this paper</a>
exists and is something that you should look into if you&rsquo;re interested. There&rsquo;s also <a href="https://github.com/pliniker/mo-gc/blob/master/doc/Project-RFC.md">an RFC</a>
by Peter Liniker which sketches out a design for an immutable GC.</p>

<h2>Core Rust GC(s)</h2>

<p>Rust itself had a garbage collector until a bit more than a year ago. These &ldquo;managed pointers&rdquo;
(<code>@T</code>) were part of the language. They were removed later with a plan to make GC a library feature.</p>

<p>I believe these were basically reference counted (cycle collected?) pointers with some language
integration, but I&rsquo;m not sure.</p>

<p>Nowadays, the only form of automatic memory management in Rust are via <a href="http://doc.rust-lang.org/alloc/rc/struct.Rc.html"><code>Rc</code></a> and <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>
which are nonatomic and atomic reference counted pointers respectively. In other words, they keep
track of the number of shared references via a reference count (incremented when it is cloned,
decremented when destructors run). If the reference count reaches zero, the contents are cleaned up.</p>

<p>This is a pretty useful abstraction, however, as mentioned above, it doesn&rsquo;t let you create cycles
without leaking them.</p>

<h2>Spidermonkey</h2>

<p><em>You can read more about Servo&rsquo;s Spidermonkey bindings <a href="https://blog.mozilla.org/research/2014/08/26/javascript-servos-only-garbage-collector/">in this blog post</a> (somewhat
outdated, but still relevant)</em></p>

<p>In Servo we use <a href="http://github.com/servo/rust-mozjs/">bindings to the Spidermonkey Javascript engine</a>. Since Javascript is a
garbage collected language, the Rust representations of Javascript objects are also garbage
collected.</p>

<p>Of course, this sort of GC isn&rsquo;t really useful for generic use since it comes bundled with a JS
runtime. However, the Rust side of the GC is of a design that could be used in an independent
library.</p>

<p>The Rust side of the Spidermonkey GC is done through a bunch of smart pointers, and a trait called
<code>JSTraceable</code>. <code>JSTraceable</code> is a trait which can &ldquo;trace&rdquo; recursively down some data, finding and
marking all GC-managed objects inside it. This is autoderived using Rust&rsquo;s plugin infrastructure, so
a simple <code>#[jstraceable]</code> annotation will generate trace hooks for the struct it is on.</p>

<p>Now, we have various smart pointers. The first is <code>JS&lt;T&gt;</code>. This is opaque, but can be held by other
GC-managed structs. To use this on the stack, this must be explicitly <em>rooted</em>, via <code>.root()</code>. This
produces a <code>Root&lt;T&gt;</code>, which can be dereferenced to get the inner object. When the <code>Root</code> is created,
the contained object is listed in a collection of &ldquo;roots&rdquo; in a global. A root indicates that the
value is being used on the stack somewhere, and the GC starts tracing usage from these roots. When
the <code>Root&lt;T&gt;</code> is destroyed, the root is removed.</p>

<p>The problem with this is that <code>JS&lt;T&gt;</code> doesn&rsquo;t work on the stack. There is no way for the GC to know
that we are holding on to <code>JS&lt;T&gt;</code> on the stack. So, if I copy a <code>JS&lt;T&gt;</code> to the stack, remove all
references to it from objects in the GC heap, and trigger a collection, the <code>JS&lt;T&gt;</code> will still be
around on the stack after collection since the GC can&rsquo;t trace to it. If I attempt to root it, I may
get a panic or a segfault depending on the implementation.</p>

<p>To protect against this, we have a bunch of lints. The <a href="https://github.com/servo/servo/blob/master/components/plugins/lints/unrooted_must_root.rs">relevant one</a> here protects
against <code>JS&lt;T&gt;</code> from being carried around on the stack; but like most lints, it&rsquo;s not perfect.</p>

<p>To summarize: Spidermonkey gives us a good GC. However using it for a generic Rust program is ill
advised. Additionally, Servo&rsquo;s wrappers around the GC are cheap, but need lints for safety. While it
would probably be possible to write safer wrappers for general usage, it&rsquo;s pretty impractical to
carry around a JS runtime when you don&rsquo;t need one.</p>

<p>However, Spidermonkey&rsquo;s GC did inspire me to think more into the matter.</p>

<h1>Brainstorming a design</h1>

<p>For quite a while I&rsquo;d had various ideas about GCs. Most were simplifications of Servo&rsquo;s wrappers
(there&rsquo;s some complexity brought in there by Spidermonkey that&rsquo;s not necessary for a general GC).
Most were tracing/rooting with mark-and-sweep collection. All of them used lints. Being rather busy,
I didn&rsquo;t really work on it past that, but planned to work on it if I could find someone to work
with.</p>

<p>One day, <a href="http://github.com/mystor">Michael</a> pinged me on IRC and asked me about GCs. Lots of people knew that I was
interested in writing a GC for Rust, and one of them directed him to me when he expressed a similar
interest.</p>

<p>So we started discussing GCs. We settled on a tracing mark-and-sweep GC. In other words, the GC runs
regular &ldquo;sweeps&rdquo; where it first &ldquo;traces&rdquo; the usage of all objects and marks them and their children
as used, and then sweeps up all unused objects.</p>

<p>This model on its own has a flaw. It doesn&rsquo;t know about GC pointers held on the stack as local
variables (&ldquo;stack roots&rdquo;). There are multiple methods for solving this. We&rsquo;ve already seen one above
in the Spidermonkey design &ndash; maintain two types of pointers (one for the stack, one for the heap),
and try very hard using static analysis to ensure that they don&rsquo;t cross over.</p>

<p>A common model (used by GCs like Boehm, called &ldquo;conservative GCs&rdquo;) is to do something called &ldquo;stack
scanning&rdquo;. In such a system, the GC goes down the stack looking for things which may perhaps be GC
pointers. Generally the GC allocates objects in known regions of the memory, so a GC pointer is any
value on the stack which belongs to one of these regions.</p>

<p>Of course, this makes garbage collection rather inefficient, and will miss cases like <code>Box&lt;Gc&lt;T&gt;&gt;</code>
where the GCd pointer is accessible, but through a non-GC pointer.</p>

<p>We decided rather early on that we didn&rsquo;t want a GC based on lints or stack scanning. Both are
rather suboptimal solutions in my opinion, and very hard to make sound<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. We were also hoping that
Rust&rsquo;s type system and ownership semantics could help us in designing a good, safe, API.</p>

<p>So, we needed a way to keep track of roots, and we needed a way to trace objects.</p>

<h2>Tracing</h2>

<p>The latter part was easy. We wrote a compiler plugin (well, we stole <a href="https://github.com/servo/servo/blob/master/components/plugins/jstraceable.rs#L38">Servo&rsquo;s tracing plugin which
I&rsquo;d written earlier</a>) which autoderives an implementation of the <code>Trace</code> trait on any
given struct or enum, using the same internal infrastructure that <code>#[derive(PartialEq)]</code> and the
rest use. So, with just the following code, it&rsquo;s easy to make a struct or enum gc-friendly:</p>

<pre><code class="rust">#[derive(Trace)]
struct Foo {
    x: u8,
    y: Bar,
}

#[derive(Trace)]
enum Bar {
    Baz(u8), Quux
}
</code></pre>

<p>For a <code>foo</code> of type <code>Foo</code> <code>foo.trace()</code>, will expand to a call of <code>foo.x.trace()</code> and
<code>foo.y.trace()</code>. <code>bar.trace()</code> will check which variant it is and call <code>trace()</code> on the <code>u8</code> inside
if it&rsquo;s a <code>Baz</code>. For most structs this turns out to be a no-op and is often optimized away by
inlining, but if a struct contains a <code>Gc&lt;T&gt;</code>, the special implementation of <code>Trace</code> for <code>Gc&lt;T&gt;</code> will
&ldquo;mark&rdquo; the traceability of the <code>Gc&lt;T&gt;</code>. Types without <code>Trace</code> implemented cannot be used in types
implementing <code>Trace</code> or in a <code>Gc</code>, which is enforced with a <code>T: Trace</code> bound on <code>Gc&lt;T&gt;</code>.</p>

<p>So, we have a way of walking the fields of a given object and finding inner <code>Gc&lt;T&gt;</code>s. Splendid. This
lets us write the mark&amp;sweep phase easily: Take the list of known reachable <code>Gc&lt;T&gt;</code>s, walk their
contents until you find more <code>Gc&lt;T&gt;</code>s (marking all you find), and clean up any which aren&rsquo;t
reachable.</p>

<h2>Rooting</h2>

<p>Of course, now we have to solve the problem of keeping track of the known reachable <code>Gc&lt;T&gt;</code>s, i.e.
the roots. This is a hard problem to solve without language support, and I hope that eventually we
might be able to get the language hooks necessary to solve it. LLVM <a href="http://llvm.org/docs/GarbageCollection.html#gcroot">has support for tracking
GCthings on the stack</a>, and some day we may be able to leverage that in Rust.</p>

<p>As noted above, Spidermonkey&rsquo;s solution was to have non-rooted (non-dereferencable) heap pointers,
which can be explicitly converted to rooted pointers and then read.</p>

<p>We went the other way. All <code>Gc&lt;T&gt;</code> pointers, when created, are considered &ldquo;rooted&rdquo;. The instance of
<code>Gc&lt;T&gt;</code> has a &ldquo;rooted&rdquo; bit set to true, and the underlying shared box (<code>GcBox</code>, though this is not a
public interface) has its &ldquo;root count&rdquo; set to one.</p>

<p>When this <code>Gc&lt;T&gt;</code> is cloned, an identical <code>Gc&lt;T&gt;</code> (with rooted bit set to true) is returned, and the
underlying root count is incremented. Cloning a <code>Gc</code> does not perform a deep copy.</p>

<pre><code class="rust">let a = Gc::new(20); // a.root = true, (*a.ptr).roots = 1, (*a.ptr).data = 20

// ptr points to the underlying box, which contains the data as well as
// GC metadata like the root count. `Gc::new()` will allocate this box

let b = a.clone(); // b.root = true, (*a.ptr).roots++, b.ptr = a.ptr
</code></pre>

<p>This is rather similar to how <code>Rc</code> works, however there is no <code>root</code> field, and the <code>roots</code> counter
is called a &ldquo;reference counter&rdquo;.</p>

<p>For regular local sharing, it is recommended to just use a borrowed reference to the inner variable
(borrowing works fine with rust-gc!) since there is no cost to creating this reference.</p>

<p>When a GC thing is put inside another GC thing, the first thing no longer can remain a root. This is
handled by &ldquo;unrooting&rdquo; the first GC thing:</p>

<pre><code class="rust">struct Foo {
    bar: u32,
    baz: Gc&lt;u32&gt;,
}

let a = Gc::new(20); // why anyone would want to GC an integer I'll never know
                     // but I'll stick with this example since it's simple

let b = Gc::new(Foo {bar: 1, baz: a});
// a.root = false, (*a.ptr).roots--
// b initialized similar to previous example

// `a` was moved into `b`, so now `a` cannot be accessed directly here
// other than through `b`, and `a` is no longer a root.
// To avoid moving a, passing `a.clone()` to `b` will work
</code></pre>

<p>Of course, we need a way to traverse the object passed to the <code>Gc&lt;T&gt;</code>, in this case <code>Foo</code>, and look
for any contained <code>Gc&lt;T&gt;</code>s to unroot. Sound familiar? This needs the same mechanism that <code>trace()</code>
needed! We add struct-walking <code>root()</code> and <code>unroot()</code> methods to the <code>Trace</code> trait which are auto-
derived exactly the same way, and continue. (We don&rsquo;t need <code>root()</code> right now, but we will need it
later on).</p>

<p>Now, during collection, we can just traverse the list of <code>GcBox</code>s and use the ones with a nonzero
root count as roots for our mark traversal.</p>

<p>So far, so good. We have a pretty sound design for a GC that works &hellip; for immutable data.</p>

<h3>Mutability</h3>

<p>Like <code>Rc&lt;T&gt;</code>, <code>Gc&lt;T&gt;</code> is by default immutable. Rust abhors aliasable mutability, <a href="http://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/">even in single
threaded contexts</a>, and both these smart pointers allow aliasing.</p>

<p>Mutation poses a problem for our GC, beyond the regular problems of aliasable mutability: It&rsquo;s
possible to move rooted things into heap objects and vice versa:</p>

<pre><code class="rust">let x = Gc::new(20);

let y = Gc::new(None);

*y = Some(x); // uh oh, x is still considered rooted!

// and the reverse!

let y = Gc::new(Some(Gc::new(20)));

let x = y.take(); // x was never rooted!
// `take()` moves the `Some(Gc&lt;u32&gt;)` out of `y`, replaces it with `None`       
</code></pre>

<p>Since <code>Gc&lt;T&gt;</code> doesn&rsquo;t implement <code>DerefMut</code>, none of this is possible &mdash; one cannot mutate the
inner data. This is one of the places where Rust&rsquo;s ownership/mutability system works out awesomely
in our favor.</p>

<p>Of course, an immutable GC isn&rsquo;t very useful. We can&rsquo;t even create cycles in an immutable GC, so why
would anyone need this in the first place<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>?</p>

<p>So of course, we needed to make it somehow mutable. People using <code>Rc&lt;T&gt;</code> solve this problem by using
<code>RefCell&lt;T&gt;</code>, which maintains something similar to the borrow semantics at runtime and is internally
mutable. <code>RefCell&lt;T&gt;</code> itself can&rsquo;t be used by us since it doesn&rsquo;t guard against the problem
illustrated above (and hence won&rsquo;t implement <code>Trace</code>, but a similar cell type would work).</p>

<p>So we created <code>GcCell&lt;T&gt;</code>. This behaves just like <code>RefCell&lt;T&gt;</code>, except that it will <code>root()</code> before
beginning a mutable borrow, and <code>unroot()</code> before ending it (well, only if it itself is not rooted,
which is tracked by an internal field similar to <code>Gc&lt;T&gt;</code>). Now, everything is safe:</p>

<pre><code class="rust">#[derive(Trace)]
struct Foo {
    a: u8,
    b: GcCell&lt;Gc&lt;u8&gt;&gt;,
}

let x = Gc::new(20);

let y = Gc::new(Foo {a: 10, b: Gc::new(30)});
{
    *y.b.borrow_mut() = x; // the `Gc(30)` from `y.b` was rooted by this call
                           // but since we don't actually use it here,
                           // the destructor gets rid of it.
                           // We could use swap() to retain access to it.
    // ...
    // x unrooted
}


// and the reverse case works too:

let y = Gc::new(GcCell::new(Some(Gc::new(20))));

let x = y.borrow_mut().take(); // the inner `Some(Gc(20))` gets rooted by `borrow_mut()`
                               // before `x` can access it
</code></pre>

<p>So now, mutation works too! We have a working garbage collector!</p>

<h1>Open problems</h1>

<h2>Destructors</h2>

<p>I believe this can be solved without lints, but it <em>may</em> require some upcoming features of Rust to
be implemented first (like specialization).</p>

<p>In essence, destructors implemented on a value inside <code>Gc&lt;T&gt;</code> can be unsafe. This will only happen
if they try to access values within a <code>Gc&lt;T&gt;</code> &mdash; if they do, they may come across a box that
has already been collected, or they may lengthen the lifetime of a box scheduled to be collected.</p>

<p>The basic solution to this is to use &ldquo;finalizers&rdquo; instead of destructors. Finalizers, like in Java,
are not guaranteed to run. However, we may need further drop hooks or trait specialization to make
an airtight interface for this. I don&rsquo;t have a concrete design for this yet, though.</p>

<h2>Concurrency</h2>

<p>Our model mostly just works in a concurrent situation (with thread safety tweaks, of course); in
fact it&rsquo;s possible to make it so that the concurrent GC will not &ldquo;stop the world&rdquo; unless someone
tries to do a write to a <code>GcCell</code>. We have an experimental concurrent GC in <a href="https://github.com/Manishearth/rust-gc/pull/6">this pull
request</a>. We still need to figure out how to make interop between both GCs safe, though we may
just end up making them such that an object using one GC cannot be fed to an object using the other.</p>

<h2>Performance</h2>

<p>So far we haven&rsquo;t really focused on performance, and worked on ensuring safety. Our collection
triggering algorithm, for example, was horribly inefficient, though we planned on improving it. The
wonderful Huon <a href="https://github.com/Manishearth/rust-gc/pull/9">fixed this</a>, though.</p>

<p>Similarly, we haven&rsquo;t yet optimized storage. We have some ideas which we may work on later. (If you
want to help, contributions welcome!)</p>

<h2>Cross-crate deriving</h2>

<p>Currently, an object deriving <code>Trace</code> should have <code>Trace</code>able children. This isn&rsquo;t always possible
when members from another crate (which does not depend on rust-gc) are involved. At the moment, we
allow an <code>#[unsafe_ignore_trace]</code> annotation on fields which are of this type (which excludes it
from being traced &ndash; if that crate doesn&rsquo;t transitively depend on rust-gc, its members cannot
contain GCthings anyway unless generics are involved). It should be possible to detect whether or
not this is safe, and/or autoderive <code>Trace</code> using the opt-in builtin traits framework (needs
specialization to work), but at the moment we don&rsquo;t do anything other than expose that annotation.</p>

<p>Stdlib support for a global <code>Trace</code> trait that everyone derives would be awesome.</p>

<h1>Conclusion</h1>

<p>Designing a GC was a wonderful experience! I didn&rsquo;t get to write much code (I was busy and Michael
was able to implement most of it overnight because he&rsquo;s totally awesome), but the long design
discussions followed by trying to figure out holes in the GC design in every idle moment of the day
were quite enjoyable. GCs are very hard to get right, but it&rsquo;s very satisfying when you come up with
a design that works! I&rsquo;m also quite happy at how well Rust helped in making a safe interface.</p>

<p>I encourage everyone to try it out and/or find holes in our design. Contributions of all kind
welcome, we&rsquo;d especially love performance improvements and testcases.</p>

<p><small>Discuss: <a href="https://news.ycombinator.com/item?id=10148471">HN</a>, <a href="https://www.reddit.com/r/rust/comments/3j4bx2/designing_a_gc_in_rust/">Reddit</a></small></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m very skeptical that it&rsquo;s possible to make either of these completely sound without writing lints which effectively rewrite a large chunk of the compiler<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>There is a case to be made for an immutable GC which allows some form of deferred initialization of GC fields, however.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The World's Most Over-engineered Alarm Clock]]></title>
    <link href="http://manishearth.github.io/blog/2015/08/29/the-worlds-most-over-engineered-alarm-clock/"/>
    <updated>2015-08-29T00:08:59+05:30</updated>
    <id>http://manishearth.github.io/blog/2015/08/29/the-worlds-most-over-engineered-alarm-clock</id>
    <content type="html"><![CDATA[<p>A few weeks ago, I set up my Raspberry Pi as a music server so that I could listen to music without
having to deal with keeping my laptop in a certain corner of the room.</p>

<p>After setting it all up, it occurred to me: &ldquo;I can do much more with this!&rdquo;.</p>

<p>Waking up to go to class in the morning is always a challenge for me. It&rsquo;s not that I don&rsquo;t wake up
&mdash; I often wake up, cancel all the alarms, and go back to bed. Half-asleep me somehow has the
skill to turn off alarms, but not the discipline of going to class<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I&rsquo;ve tried those apps that
make you do math before you can cancel the alarm, and I&rsquo;m able to do the math and go back to sleep
without fully waking up in the process (Hey, I&rsquo;m a physics student; math is what we do!).</p>

<p>So I decided to create an alarm clock. Not just any alarm clock, the most overengineered alarm clock
I can think of.</p>

<p>It consists of the Pi connected to a speaker and kept in a hard-to-reach area of the room. The Pi is
on a DHCP network. Every night, I ssh to the Pi, set the volume to full, and run a script which,
using <code>at</code> and <code>mpg123</code>, will schedule jobs to run around the desired time of waking up. First,
there will be a few pieces of soothing music (either violin music or parts of the <em>Interstellar</em>
OST) run once or twice, a while before the time of waking up. Close to the time of waking up, there
are a bunch of jobs where each one will run a string of annoying music. In my case, it&rsquo;s the
Minions&#8217; banana song followed by Nyan Cat (I sometimes add more to this list).</p>

<p>So far so good.</p>

<p>Now, the soothing music gives asleep-me me a chance to surrender and wake up <em>before</em> the Nyan Cat
begins, and often fear of Nyan Cat is a pretty good motivator to wake up. If I don&rsquo;t wake up to
the soft songs, the annoying ones invariably work.</p>

<p>At this stage I&rsquo;m still pretty groggy and have the intense urge to go back to bed. However, turning
off the alarm isn&rsquo;t simple. Since it&rsquo;s in a hard to reach area of the room, I can&rsquo;t just turn it
off. I need to get up, sit in my chair, and turn on the laptop (which is hibernated/suspended), and
kill it via ssh.</p>

<p>This needs me to:</p>

<ul>
<li><code>nmap</code> the network to find the Pi (I&rsquo;m the only one on this subnet who uses <code>ssh</code>, so this just needs a port filter)</li>
<li><code>ssh</code> into the Pi, remembering the password (I haven&rsquo;t done this yet but I could further complicate things by changing the password often to reduce muscle-memory)</li>
<li><code>killall mpg123</code> to kill the currently playing song</li>
<li>Cancel the remaining <code>at</code> jobs. This can be done with <code>atq</code> + <code>atrm</code> for every job (tedious and long), or with <code>awk</code>. If I&rsquo;ve already fully woken up, I&rsquo;m able to do the <code>awk</code> one, otherwise half-asleep me ends up doing the brute-force one, which is enough manual typing to shake the remaining bits of sleepiness off.</li>
</ul>


<p>After this whole process, it&rsquo;s pretty much guaranteed that I&rsquo;m fully awake &ndash; there&rsquo;s no going back now!</p>

<p>So far it&rsquo;s worked pretty well (both when I&rsquo;ve slept on time and when I haven&rsquo;t). The first ten minutes after this I&rsquo;m rather annoyed, but after that I&rsquo;m happy I woke up. If half-asleep me
eventually gets the muscle memory to get past this process, I should probably be able to tweak it
to add more complexity or change the way it works.</p>

<p>Of course, having an arms race with oneself probably isn&rsquo;t the best way to solve this problem. I
suspect I&rsquo;ll go back to regular alarms in a month or so, but it&rsquo;s a fun experiment for now.</p>

<p>However, by the time I&rsquo;m done with this alarm clock, I&rsquo;ll either be waking up on time, or I&rsquo;ll be
able to Linux in my sleep, which is a win-win!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>As a fourth year student the fully-awake me also has a bit of trouble with this ;)<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adventures in Systems Programming: C++ Local Statics]]></title>
    <link href="http://manishearth.github.io/blog/2015/06/26/adventures-in-systems-programming-c-plus-plus-local-statics/"/>
    <updated>2015-06-26T15:32:06+05:30</updated>
    <id>http://manishearth.github.io/blog/2015/06/26/adventures-in-systems-programming-c-plus-plus-local-statics</id>
    <content type="html"><![CDATA[<p>For a while now I&rsquo;ve been quite interested in compilers and systems programming in general; and I
feel that an important feature of systems programming is that it&rsquo;s relatively easy to figure out
what a line of code does (modulo optimizations) at the OS or hardware level<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Conversely, it&rsquo;s
important to know how your tools work more than ever in systems programming. So when I see a
language feature I&rsquo;m not familiar with, I&rsquo;m interested in finding out how it works under the hood.</p>

<p>I&rsquo;m not a C++ expert. I can work on C++ codebases, but I&rsquo;m not anywhere near knowing all of the
features and nuances of C++. However, I am pretty good at Rust and understand a decent portion of
the compiler internals. This gives me a great perspective &mdash; I&rsquo;ve not yet internalized most C++
features to take them for granted, and I&rsquo;m well equipped to investigate these features.</p>

<p>Today I came across some C++ code similar to the following<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>:</p>

<pre><code class="cpp">void foo() {
    static SomeType bar = Env()-&gt;someMethod();
    static OtherType baz = Env()-&gt;otherMethod(bar);
}
</code></pre>

<p>This code piqued my interest. Specifically, the local <code>static</code> stuff. I knew that when you have a
static like</p>

<pre><code>static int FOO = 1;
</code></pre>

<p>the <code>1</code> is stored somewhere in the <code>.data</code> section of the program. This is easily verified with <code>gdb</code>:</p>

<pre><code class="cpp">static int THING = 0xAAAA;

int main() {
 return 1;
}
</code></pre>

<pre><code class="text">$ g++ test.cpp -g
$ gdb a.out
(gdb) info addr THING
Symbol "THING" is static storage at address 0x601038.
(gdb) info symbol 0x601038
THING in section .data
</code></pre>

<p>This is basically a part of the compiled program as it is loaded into memory.</p>

<p>Similarly, when you have a <code>static</code> that is initialized with a function, it&rsquo;s stored in the <code>.bss</code>
section, and initialized before <code>main()</code>. Again, easily verified:</p>

<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;

int bar() {
 cout&lt;&lt;"bar called\n";
 return 0xFAFAFA;
}

static int THING = bar();

int main() {
 cout&lt;&lt;"main called\n";
 return 0;
}
</code></pre>

<pre><code class="text">$ ./a.out 
bar called
main called
$ gdb a.out
(gdb) info addr THING
Symbol "THING" is static storage at address 0x601198.
(gdb) info symbol 0x601198
THING in section .bss
</code></pre>

<p>We can also leave statics uninitialized (<code>static int THING;</code>) and they will be placed in <code>.bss</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>So far so good.</p>

<p>Now back to the original snippet:</p>

<pre><code class="cpp">void foo() {
    static SomeType bar = Env()-&gt;someMethod();
    static OtherType baz = Env()-&gt;otherMethod(bar);
}
</code></pre>

<p>Naïvely one might say that these are statics which are scoped locally to avoid name clashes. It&rsquo;s
not much different from <code>static THING = bar()</code> aside from the fact that it isn&rsquo;t a global
identifier.</p>

<p>However, this isn&rsquo;t the case. What tipped me off was that this called <code>Env()</code>, and I wasn&rsquo;t so sure
that the environment was guaranteed to be properly initialized and available before <code>main()</code> is
called <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>

<p>Instead, these are statics which are initialized the first time the function is called.</p>

<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;

int bar() {
 cout&lt;&lt;"bar called\n";
 return 0xFAFAFA;
}

void foo() {
 cout&lt;&lt;"foo called\n";
 static int i = bar();
 cout&lt;&lt;"Static is:"&lt;&lt; i&lt;&lt;"\n";
}

int main() {
 cout&lt;&lt;"main called\n";
 foo();
 foo();
 foo();
 return 0;
}
</code></pre>

<pre><code class="text">$ g++ test.cpp
$ ./a.out
main called
foo called
bar called
Static is:16448250
foo called
Static is:16448250
foo called
Static is:16448250
</code></pre>

<p>Wait, &ldquo;the first time the function is called&rdquo;? <em>Alarm bells go off&hellip;</em> Surely there&rsquo;s some cost to that! Let&rsquo;s investigate.</p>

<pre><code class="text">$ gdb a.out
(gdb) disas bar
   // snip
   0x0000000000400c72 &lt;+15&gt;:    test   %al,%al
   0x0000000000400c74 &lt;+17&gt;:    jne    0x400ca4 &lt;_Z3foov+65&gt;
   0x0000000000400c76 &lt;+19&gt;:    mov    $0x6021f8,%edi
   0x0000000000400c7b &lt;+24&gt;:    callq  0x400a00 &lt;__cxa_guard_acquire@plt&gt;
   0x0000000000400c80 &lt;+29&gt;:    test   %eax,%eax
   0x0000000000400c82 &lt;+31&gt;:    setne  %al
   0x0000000000400c85 &lt;+34&gt;:    test   %al,%al
   0x0000000000400c87 &lt;+36&gt;:    je     0x400ca4 &lt;_Z3foov+65&gt;
   0x0000000000400c89 &lt;+38&gt;:    mov    $0x0,%r12d
   0x0000000000400c8f &lt;+44&gt;:    callq  0x400c06 &lt;_Z3barv&gt;
   0x0000000000400c94 &lt;+49&gt;:    mov    %eax,0x201566(%rip)        # 0x602200 &lt;_ZZ3foovE1i&gt;
   0x0000000000400c9a &lt;+55&gt;:    mov    $0x6021f8,%edi
   0x0000000000400c9f &lt;+60&gt;:    callq  0x400a80 &lt;__cxa_guard_release@plt&gt;
   0x0000000000400ca4 &lt;+65&gt;:    mov    0x201556(%rip),%eax        # 0x602200 &lt;_ZZ3foovE1i&gt;
   0x0000000000400caa &lt;+71&gt;:    mov    %eax,%esi
   0x0000000000400cac &lt;+73&gt;:    mov    $0x6020c0,%edi
   // snip
</code></pre>

<p>The instruction at <code>+44</code> calls <code>bar()</code>, and it seems to be surrounded by calls to some <code>__cxa_guard</code>
functions.</p>

<p>We can take a naïve guess at what this does: It probably just sets a hidden static flag on
initialization which ensures that it only runs once.</p>

<p>Of course, the actual solution isn&rsquo;t as simple. It needs to avoid data races, handle errors, and
somehow take care of recursive initialization.</p>

<p>Let&rsquo;s look at the <a href="http://mentorembedded.github.io/cxx-abi/abi.html#once-ctor">spec</a> and one <a href="http://www.opensource.apple.com/source/libcppabi/libcppabi-14/src/cxa_guard.cxx">implementation</a>, found by searching for
<code>__cxa_guard</code>.</p>

<p>Both of them show us the generated code for initializing things like local statics:</p>

<pre><code class="cpp">  if (obj_guard.first_byte == 0) {
    if ( __cxa_guard_acquire (&amp;obj_guard) ) {
      try {
      // ... initialize the object ...;
      } catch (...) {
        __cxa_guard_abort (&amp;obj_guard);
        throw;
      }
      // ... queue object destructor with __cxa_atexit() ...;
      __cxa_guard_release (&amp;obj_guard);
    }
  }
</code></pre>

<p>Here, <code>obj_guard</code> is our &ldquo;hidden static flag&rdquo;, with some other extra data.</p>

<p><code>__cxa_guard_acquire</code> and <code>__cxa_guard_release</code> acquire and release a lock to prevent recursive
initialization. So this program will crash:</p>

<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;

void foo(bool recur);

int bar(bool recur) {
 cout&lt;&lt;"bar called\n";
 if(recur) {
    foo(false);
 }
 return 0xFAFAFA;
}

void foo(bool recur) {
 cout&lt;&lt;"foo called\n";
 static int i = bar(recur);
 cout&lt;&lt;"Static is:"&lt;&lt; i&lt;&lt;"\n";
}



int main() {
 foo(true);
 return 0;
}
</code></pre>

<pre><code class="text">$ g++ test.cpp
$ ./a.out 
foo called
bar called
foo called
terminate called after throwing an instance of '__gnu_cxx::recursive_init_error'
  what():  std::exception
Aborted (core dumped)
</code></pre>

<p>Over here, to initialize <code>i</code>, <code>bar()</code> needs to be called, but <code>bar()</code> calls <code>foo()</code> which needs <code>i</code>
to be initialized, which again will call <code>bar()</code> (though this time it won&rsquo;t recurse). If <code>i</code> wasn&rsquo;t
<code>static</code> it would be fine, but now we have two calls trying to initialize <code>i</code>, and it&rsquo;s unclear as
to which value should be used.</p>

<p>The implementation is pretty interesting. Before looking at the code my quick guess was that the
following would happen for local statics:</p>

<ul>
<li><code>obj_guard</code> is a struct containing a mutex and a flag with three states:
&ldquo;uninitialized&rdquo;, &ldquo;initializing&rdquo;, and &ldquo;initialized&rdquo;. Alternatively, use an atomic state indicator.</li>
<li>When we try to initialize for the first time, the mutex is locked, the flag is set
to &ldquo;initializing&rdquo;, the mutex is released, the value is initialized, and the flag is set to &ldquo;initialized&rdquo;.</li>
<li>If when acquiring the mutex, the value is &ldquo;initialized&rdquo;, don&rsquo;t initialize again</li>
<li>If when acquiring the mutex, the value is &ldquo;initializing&rdquo;, throw some exception</li>
</ul>


<p> (We need the tristate flag because without it recursion would cause deadlocks)</p>

<p>I suppose that this implementation would work, though it&rsquo;s not the one being used. The
<a href="https://github.com/android/platform_bionic/blob/master/libc/bionic/__cxa_guard.cpp">implementation in bionic</a> (the Android version of the C stdlib) is similar; it
uses per-static atomics which indicate various states. However, it does not throw an exception when
we have a recursive initialization, it instead seems to deadlock<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>. This is okay because the C++
spec says (<a href="http://www.open-std.org/jtc1/sc22/open/n2356/stmt.html#stmt.dcl">Section 6.7.4</a>)</p>

<blockquote><p>If control re-enters the declaration (recursively) while the object is being initialized, the
behavior is undefined.</p></blockquote>

<p>However, the implementations in <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/guard.cc">gcc/libstdc++</a> (also <a href="http://www.opensource.apple.com/source/libcppabi/libcppabi-14/src/cxa_guard.cxx">this version</a> of
<code>libcppabi</code> from Apple, which is a bit more readable) do something different. They use a global
recursive mutex to handle reentrancy. Recursive mutexes basically can be locked multiple times by a
single thread, but cannot be locked by another thread till the locking thread unlocks them the same
number of times. This means that recursion/reentrancy won&rsquo;t cause deadlocks, but we still have one-
thread-at-a-time access. What these implementations do is:</p>

<ul>
<li><code>guard_object</code> is a set of two flags, one which indicates if the static is initialized,
and one which indicates that the static is being initialized (&ldquo;in use&rdquo;)</li>
<li>If the object is initialized, do nothing (this doesn&rsquo;t use mutexes and is cheap).
This isn&rsquo;t exactly part of the implementation in the library, but is part of the generated code.</li>
<li>If it isn&rsquo;t initialized, acquire the global recursive lock</li>
<li>If the object is initialized by the time the lock was acquired, unlock and return</li>
<li>If not, check if the static is being initialized from the second <code>guard_object</code> flag. If it is
&ldquo;in use&rdquo;, throw an exception.</li>
<li>If it wasn&rsquo;t, mark the second flag of the static&rsquo;s guard object as being &ldquo;in use&rdquo;</li>
<li>Call the initialization function, bubble errors</li>
<li>Unlock the global mutex</li>
<li>Mark the second flag as &ldquo;not in use&rdquo;</li>
</ul>


<p>At any one time, only one thread will be in the process of running initialization routines, due to
the global recursive mutex. Since the mutex is recursive, a function (eg <code>bar()</code>) used for
initializing local statics may itself use (different) local statics. Due to the &ldquo;in use&rdquo; flag, the
initialization of a local static may not recursively call its parent function without causing an
error.</p>

<p>This doesn&rsquo;t need per-static atomics, and doesn&rsquo;t deadlock, however it has the cost of a global
mutex which is called at most once per local static. In a highly threaded situation with lots of
such statics, one might want to reevaluate directly using local statics.</p>

<p><a href="https://github.com/llvm-mirror/libcxxabi/blob/master/src/cxa_guard.cpp#L188">LLVM&rsquo;s libcxxabi</a> is similar to the <code>libstdc++</code> implementation, but instead of a recursive
mutex it uses a regular mutex (on non-ARM Apple systems) which is unlocked before
<code>__cxa_guard_acquire</code> exits and tests for reentrancy by noting the thread ID in the guard object
instead of the &ldquo;in use&rdquo; flag. Condvars are used for waiting for a thread to stop using an object. On
other platforms, it seems to deadlock, though I&rsquo;m not sure.</p>

<p>So here we have a rather innocent-looking feature that has some hidden costs and pitfalls. But now I
can look at a line of code where this feature is being used, and have a good idea of what&rsquo;s
happening there. One step closer to being a better systems programmer!</p>

<p><em>Thanks to Rohan Prinja, Eduard Burtescu, and Nishant Sunny for reviewing drafts of this blog post</em></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Emphasis on <em>relatively</em>. This article will show that it&rsquo;s definitely not &ldquo;easy&rdquo; all the time.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>This was JNI code which obtained a JNI environment and pulled out method/class IDs from it to be used later<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Unless it has a constructor or otherwise isn&rsquo;t made out of trivially constructible types; in this case it is treated similar to the previous case.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>I checked later, and it was indeed the case that global statics are initialized before <code>Env()</code> is ready<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>I later verified this with a modification of the crashing program above stuck inside some JNI Android code.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Rust Achieves Thread Safety]]></title>
    <link href="http://manishearth.github.io/blog/2015/05/30/how-rust-achieves-thread-safety/"/>
    <updated>2015-05-30T04:25:32+05:30</updated>
    <id>http://manishearth.github.io/blog/2015/05/30/how-rust-achieves-thread-safety</id>
    <content type="html"><![CDATA[<p><em>In every talk I have given till now, the question &ldquo;how does Rust achieve thread safety?&rdquo;
has invariably come up<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I usually just give an overview, but this provides a more comprehensive
explanation for those who are interested</em></p>

<p>See also: <a href="http://huonw.github.io/blog/2015/02/some-notes-on-send-and-sync/">Huon&rsquo;s blog post on the same topic</a></p>

<p>In my <a href="http://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">previous post</a> I touched a bit on the <a href="http://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait. There are other such &ldquo;marker&rdquo; traits
in the standard library, and the ones relevant to this discussion are <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>.
I recommend reading that post if you&rsquo;re not familiar with Rust wrapper types like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> and <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>,
since I&rsquo;ll be using them as examples throughout this post; but the concepts explained here are largely independent.</p>

<p>For the purposes of this post, I&rsquo;ll restrict thread safety to mean no data races or cross-thread dangling pointers.
Rust doesn&rsquo;t aim to solve race conditions. However, there are projects which utilize the type system to provide
some form of extra safety, for example <a href="https://github.com/Munksgaard/rust-sessions">rust-sessions</a> attempts to
provide protocol safety using session types.</p>

<p>These traits are auto-implemented using a feature called &ldquo;opt in builtin traits&rdquo;. So,
for example, if struct <code>Foo</code> is <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, all structs containing <code>Foo</code> will
also be <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, unless we explicitly opt out using <code>impl !Sync for Bar {}</code>. Similarly,
if struct <code>Foo</code> is not <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, structs containing it will not be <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> either,
unless they explicitly opt in (<code>unsafe impl Sync for Bar {}</code>)</p>

<p>This means that, for example, a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a> for a <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> type is itself <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>,
but a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a> for a non-<code>Send</code> type will not be <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. This pattern is quite powerful;
it lets one use channels with non-threadsafe data in a single-threaded context without
requiring a separate &ldquo;single threaded&rdquo; channel abstraction.</p>

<p>At the same time, structs like <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> and <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> which contain <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>/<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> fields
have explicitly opted out of one or more of these because the invariants they rely on do not
hold in threaded situations.</p>

<p>It&rsquo;s actually possible to design your own library with comparable thread safety guarantees outside
of the compiler &mdash; while these marker traits are specially treated by the compiler, the special
treatment is not necessary for their working. Any two opt-in builtin traits could be used here.</p>

<p><a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> have slightly differing meanings, but are very intertwined.</p>

<p><a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> types can be moved between threads without an issue. It answers the question
&ldquo;if this variable were moved to another thread, would it still be valid for use?&rdquo;.
Most objects which completely own their contained data qualify here. Notably, <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> doesn&rsquo;t
(since it is shared ownership). Another exception is <a href="https://doc.rust-lang.org/nightly/std/thread/struct.LocalKey.html"><code>LocalKey</code></a>, which
<em>does</em> own its data but isn&rsquo;t valid from other threads. Borrowed data does qualify to be <code>Send</code>, but
in most cases it can&rsquo;t be sent across threads due to a constraint that will be touched upon later.</p>

<p>Even though types like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> use non-atomic reference counting, it can be sent safely
between threads because this is a transfer of <em>ownership</em> (a move). Sending a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to another thread
will be a move and will make it unusable from the original thread; so this is fine.</p>

<p><a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, on the other hand, is about synchronous access. It answers the question: &ldquo;if
multiple threads were all trying to access this data, would it be safe?&rdquo;. Types like
<a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> and other lock/atomic based types implement this, along with primitive types.
Things containing pointers generally are not <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>.</p>

<p><code>Sync</code> is sort of a crutch to <code>Send</code>; it helps make other types <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> when sharing is
involved. For example, <code>&amp;T</code> and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> are only <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> when the inner data is <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> (there&rsquo;s an additional
<a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> bound in the case of <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>). In words, stuff that has shared/borrowed ownership can be sent
to another thread if the shared/borrowed data is synchronous-safe.</p>

<p><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>, while <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, is not <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> because of the non atomic reference counting.</p>

<p>Bringing it together, the gatekeeper for all this is <a href="http://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn()</code></a>. It has the signature</p>

<pre><code class="rust">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; where F: FnOnce() -&gt; T, F: Send + 'static, T: Send + 'static
</code></pre>

<p>Admittedly, this is confusing/noisy, partially because it&rsquo;s allowed to return a value, and also because
it returns a handle from which we can block on a thread join. We can conjure a simpler <code>spawn</code> API for our needs though:</p>

<pre><code class="rust">pub fn spawn&lt;F&gt;(f: F) where F: FnOnce(), F: Send + 'static
</code></pre>

<p>which can be called like:</p>

<pre><code class="rust">let mut x = vec![1,2,3,4];

// `move` instructs the closure to move out of its environment
thread::spawn(move || {
   x.push(1);

});

// x is not accessible here since it was moved
</code></pre>

<p>In words, <code>spawn()</code> will take a callable (usually a closure) that will be called once, and contains
data which is <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <code>'static</code>. Here, <code>'static</code> just means that there is no borrowed
data contained in the closure. This is the aforementioned constraint that prevents the sharing of
borrowed data across threads; without it we would be able to send a borrowed pointer to a thread that
could easily outlive the borrow, causing safety issues.</p>

<p>There&rsquo;s a slight nuance here about the closures &mdash; closures can capture outer variables,
but by default they do so by-reference (hence the <code>move</code> keyword). They autoimplement <code>Send</code>
and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> depending on their capture clauses. For more on their internal representation,
see <a href="http://huonw.github.io/blog/2015/05/finding-closure-in-rust/">huon&rsquo;s post</a>. In this case, <code>x</code> was captured by-move; i.e. as <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>
(instead of being similar to <code>&amp;Vec&lt;T&gt;</code> or something), so the closure itself can be <code>Send</code>.
Without the <code>move</code> keyword, the closure would not be `&lsquo;static&rsquo; since it contains borrowed
content.</p>

<p>Since the closure inherits the <code>Send</code>/<code>Sync</code>/<code>'static</code>-ness of its captured data, a closure
capturing data of the correct type will satisfy the <code>F: Send+'static</code> bound.</p>

<p>Some examples of things that are allowed and not allowed by this function (for the type of <code>x</code>):</p>

<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>, <a href="http://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> are allowed because they are <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <code>'static</code> (when the inner type is of the same kind)</li>
<li><code>&amp;T</code> isn&rsquo;t allowed because it&rsquo;s not <code>'static</code>. This is good, because borrows should have a statically-known lifetime. Sending a borrowed pointer to a thread may lead to a use after free, or otherwise break aliasing rules.</li>
<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> isn&rsquo;t <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, so it isn&rsquo;t allowed. We could have some other <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>s hanging around, and end up with a data race on the refcount.</li>
<li><code>Arc&lt;Vec&lt;u32&gt;&gt;</code> is allowed (<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> is <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> if the inner type is); we can&rsquo;t cause a safety violation here. Iterator invalidation requires mutation, and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> doesn&rsquo;t provide this by default.</li>
<li><code>Arc&lt;Cell&lt;T&gt;&gt;</code> isn&rsquo;t allowed. <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> provides copying-based internal mutability, and isn&rsquo;t <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> (so the <code>Arc&lt;Cell&lt;T&gt;&gt;</code> isn&rsquo;t <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>). If this were allowed, we could have cases where larger structs are getting written to from different threads simultaneously resulting in some random mishmash of the two. In other words, a data race.</li>
<li><code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> are allowed (for <code>Send</code> <code>T</code>). The inner types use threadsafe locks and provide lock-based internal mutability. They can guarantee that only one thread is writing to them at any point in time. For this reason, the mutexes are <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> regardless of the inner <code>T</code> (as long as it is <code>Send</code>), and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> types can be shared safely with wrappers like <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>. From the point of view of the inner type, it&rsquo;s only being accessed by one thread at a time (slightly more complex in the case of <a href="http://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>), so it doesn&rsquo;t need to know about the threads involved. There can&rsquo;t be data races when <code>Sync</code> types like these are involved.</li>
</ul>


<p>As mentioned before, you can in fact create a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a>/<a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html"><code>Receiver</code></a> pair of non-<code>Send</code> objects. This sounds a bit
counterintuitive &mdash; shouldn&rsquo;t we be only sending values which are <code>Send</code>? However, <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender&lt;T&gt;</code></a> is only
<code>Send</code> if <code>T</code> is <code>Send</code>; so even if we can use a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a> of a non-<code>Send</code> type, we cannot send it to another thread,
so it cannot be used to violate thread safety.</p>

<p>There is also a way to utilize the <code>Send</code>-ness of <code>&amp;T</code> (which is not <code>'static</code>) for some <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> <code>T</code>, namely <a href="http://doc.rust-lang.org/std/thread/fn.scoped.html"><code>thread::scoped</code></a>.
This function does not have the <code>'static</code> bound, but it instead has an RAII guard which forces a join before the borrow ends. This
allows for easy fork-join parallelism without necessarily needing a <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>.
Sadly, there <a href="http://cglab.ca/~abeinges/blah/everyone-peaches/">are</a> <a href="http://smallcultfollowing.com/babysteps/blog/2015/04/29/on-reference-counting-and-leaks/">problems</a> which crop up when this interacts with <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> cycles, so the API
is currently unstable and will be redesigned. This is not a problem with the language design or the design of <code>Send</code>/<code>Sync</code>,
rather it is a perfect storm of small design inconsistencies in the libraries.</p>

<p><small>Discuss: <a href="https://news.ycombinator.com/item?id=9628131">HN</a>, <a href="https://www.reddit.com/r/rust/comments/37s5x2/how_rust_achieves_thread_safety/">Reddit</a></small></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>So much that I added bonus slides about thread safety to the end of my deck, and of course I ended up using them at the talk I gave recently<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Github Streak: End-game and Post-mortem]]></title>
    <link href="http://manishearth.github.io/blog/2015/05/28/github-streak-end-game-and-post-mortem/"/>
    <updated>2015-05-28T07:48:53+05:30</updated>
    <id>http://manishearth.github.io/blog/2015/05/28/github-streak-end-game-and-post-mortem</id>
    <content type="html"><![CDATA[<p>More than a <a href="http://inpursuitoflaziness.blogspot.in/2014/02/50-shades-of-green.html">year ago</a> I blogged (and <a href="http://inpursuitoflaziness.blogspot.in/2014/04/50-more-shades-of-green.html">blogged again</a> later) about my
<a href="https://github.com/Manishearth">ongoing github streak</a>.</p>

<p>The GitHub streak has since gone on for more than 500 days<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, and has been a really enriching experience.</p>

<p>Yesterday; I noticed something. I had reached end-game with this exercise. The streak is something I don&rsquo;t think about anymore,
and I don&rsquo;t make any efforts to keep it going. It just &hellip; happens. My involvement in open source has reached a level where
I don&rsquo;t need to consciously try contributing daily; I have enough interests/responsibilities that the streak is a side effect. This is despite
my current internship being at a place where the code I&rsquo;m working on is not hosted on GitHub (unlike last year). If the streak breaks, I won&rsquo;t
particularly care; and I <em>haven&rsquo;t</em> been caring for a while now.</p>

<p>&hellip; I think that&rsquo;s amazing. Despite me not realizing it at the time, this is the state of affairs that such an exercise would ideally
lead to &mdash; the initial motivation for the exercise replaced with something more substantial, until the excercise is no longer relevant.</p>

<p>I initially started this off after realizing that I had inadvertantly been contributing daily to open source for a week or so. In the past, my
contributions to open source used to be in bursts, which meant that I would be out of touch at times. I decided to try and work on extending this.
After around 30 days, I had a concrete habit. After around 40, I realized that I&rsquo;d become much more efficient at working on random bugs (even in unfamiliar codebases),
thus being able to spend more time writing real code.</p>

<p>Initially I had set a bunch of rules (listed in my <a href="http://inpursuitoflaziness.blogspot.in/2014/02/50-shades-of-green.html">original post</a>), which had stuff like issues/readme edits not counting (and no date manipulation!). I tweaked the rules around the 80-mark
to include issues/readmes when I had written code that day but it was lost in a commit squash or rebase. I think much later I dropped the rules about issues and readme edits entirely;
just considering &ldquo;anything that shows up on the punchcard which is not a result of date manipulation&rdquo; to be valid. At that point I was already quite involved in multiple projects
and didn&rsquo;t care so much about the streak or the original rules &mdash; it was just a habit at that point.</p>

<p>Now, I&rsquo;m a regular contributor to both the <a href="https://github.com/servo/servo">Servo</a> and <a href="https://github.com/rust-lang/rust">Rust</a> projects. I also have a bunch of personal projects (<a href="https://github.com/Manishearth/rust-clippy">some</a> <a href="https://github.com/Manishearth/rust-tenacious">lints</a> <a href="https://github.com/Manishearth/rust-extensible">and</a> <a href="https://github.com/Manishearth/rust-adorn">syntax extensions</a> for Rust, as well as a <a href="https://github.com/Manishearth/rust-gc/">gc</a>, along with a lot of older projects that I don&rsquo;t actively work on but maintain) and am trying to regularly blog. I&rsquo;ve
also gotten well into the habit of sending pull requests for fixing mistakes or annoyances. When all this comes together, I end up with at least one contribution a day. Sometimes more.
I have tons of things queued that I want to work on (both personal and as a part of Servo/Rust/elsewhere), if only I had the time.</p>

<p>If you do have enough spare time, I do recommend trying this. Once you get enough momentum the power of habit will keep it going, and if
my case is anything of an indicator<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> you&rsquo;ll eventually have a good chunk of contributions and some concrete open source involvement.</p>

<p>Please note that GitHub streaks shouldn&rsquo;t be used as a metric, <em>ever</em>. They&rsquo;re great for self motivation. As a metric for tracking employee performance,
or for filtering interview candidates; not so much. It&rsquo;s way too rough a metric (like LoC written), and oversimplifies the work that goes into code.
As far as using it to boost interview candidates; not everyone has the time or inclination to contribute to open source after a day job in programming,
and <em>that&rsquo;s okay</em>. I&rsquo;m a physics student &mdash; programming is like a hobby for me<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> which I&rsquo;ll gladly do daily. Now that I have a programming intern,
I&rsquo;m pretty sure there will be days where I don&rsquo;t want to program further after leaving the office.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The punchcard on GitHub only shows 400-something because the streak got retroactively broken by some deletion or rebase &mdash; at that point I didn&rsquo;t care enough to investigate<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>It could equally be just a bunch of luck with meeting the right people and choosing the right projects<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Though now it&rsquo;s a serious hobby which is a possible career option<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
