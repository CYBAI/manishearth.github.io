<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tidbits | In Pursuit of Laziness]]></title>
  <link href="http://manishearth.github.io/blog/categories/tidbits/atom.xml" rel="self"/>
  <link href="http://manishearth.github.io/"/>
  <updated>2017-01-11T01:14:16-08:00</updated>
  <id>http://manishearth.github.io/</id>
  <author>
    <name><![CDATA[Manish Goregaokar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rust Tidbits: Box Is Special]]></title>
    <link href="http://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/"/>
    <updated>2017-01-10T22:59:43-08:00</updated>
    <id>http://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special</id>
    <content type="html"><![CDATA[<p>Rust is not a simple language. As with any such language, it has many little tidbits of complexity
that most folks aren&rsquo;t aware of. Many of these tidbits are ones which may not practically matter
much for everyday Rust programming, but are interesting to know. Others may be more useful. I&rsquo;ve
found that a lot of these aren&rsquo;t documented anywhere (not that they always should be), and sometimes
depend on knowledge of compiler internals or history. As a fan of programming trivia myself, I&rsquo;ve
decided to try writing about these things whenever I come across them. &ldquo;Tribal Knowledge&rdquo; shouldn&rsquo;t
be a thing in a programming community; and trivia is fun!</p>

<hr />

<p>So. <code>Box&lt;T&gt;</code>. Your favorite heap allocation type that nobody uses<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>I was discussing some stuff on the rfcs repo when
<a href="https://github.com/rust-lang/rfcs/issues/1850#issuecomment-271766300">@burdges realized that <code>Box&lt;T&gt;</code> has a funky <code>Deref</code> impl</a>.</p>

<p>Let&rsquo;s <a href="https://github.com/rust-lang/rust/blob/e4fee525e04838dabc82beed5ae1a06051be53fd/src/liballoc/boxed.rs#L502">look at it</a>:</p>

<pre><code class="rust">#[stable(feature = "rust1", since = "1.0.0")]
impl&lt;T: ?Sized&gt; Deref for Box&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}

#[stable(feature = "rust1", since = "1.0.0")]
impl&lt;T: ?Sized&gt; DerefMut for Box&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        &amp;mut **self
    }
}
</code></pre>

<p>Wait, what? <em>Squints</em></p>

<pre><code class="rust">    fn deref(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
</code></pre>

<p><em>The call is coming from inside the house!</em></p>

<p>In case you didn&rsquo;t realize it, this deref impl returns <code>&amp;**self</code> &ndash; since <code>self</code>
is an <code>&amp;Box&lt;T&gt;</code>, dereferencing it once will provide a <code>Box&lt;T&gt;</code>, and the second dereference
will dereference the box to provide a <code>T</code>. We then wrap it in a reference and return it.</p>

<p>But wait, we are <em>defining</em> how a <code>Box&lt;T&gt;</code> is to be dereferenced (that&rsquo;s what <code>Deref::deref</code> is
for!), such a definition cannot itself dereference a <code>Box&lt;T&gt;</code>! That&rsquo;s infinite recursion.</p>

<p>And indeed. For any other type such a <code>deref</code> impl would recurse infinitely. If you run
<a href="https://play.rust-lang.org/?gist=9c8a02336c6816e57c83de39c103ca06&amp;version=stable&amp;backtrace=0">this code</a>:</p>

<pre><code class="rust">use std::ops::Deref;

struct LolBox&lt;T&gt;(T);

impl&lt;T&gt; Deref for LolBox&lt;T&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
</code></pre>

<p>the compiler will warn you:</p>

<pre><code class="text">warning: function cannot return without recurring, #[warn(unconditional_recursion)] on by default
 --&gt; &lt;anon&gt;:7:5
  |
7 |     fn deref(&amp;self) -&gt; &amp;T {
  |     ^
  |
note: recursive call site
 --&gt; &lt;anon&gt;:8:10
  |
8 |         &amp;**self
  |          ^^^^^^
  = help: a `loop` may express intention better if this is on purpose
</code></pre>

<p>Actually trying to dereference the type will lead to a stack overflow.</p>

<p>Clearly something is fishy here. Turns out, <code>Box&lt;T&gt;</code> is special.</p>

<p>This is partly due to historical accident.</p>

<p>To understand this, we must look back to Ye Olde days of pre-1.0 Rust (ca 2014). Back in these days,
we had none of this newfangled &ldquo;stability&rdquo; business. The compiler broke your code every two weeks.
Of course, you wouldn&rsquo;t <em>know</em> that because the compiler would usually crash before it could tell
you that your code was broken! Sigils roamed the lands freely, and cargo was but a newborn child
which was destined to eventually end the tyranny of Makefiles. People were largely happy knowing
that their closures were safely boxed and their threads sufficiently green.</p>

<p>Back in these days, we didn&rsquo;t have <code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, or <code>String</code>. We had <code>~T</code>, <code>~[T]</code>, and <code>~str</code>.
The second two are <em>not</em> equivalent to <code>Box&lt;[T]&gt;</code> and <code>Box&lt;str&gt;</code>, even though they may look like it,
they are both growable containers like <code>Vec&lt;T&gt;</code> and <code>String</code>. <code>~</code> conceptually meant &ldquo;owned&rdquo;, though
IMO that caused more confusion than it was worth.</p>

<p>You created a box using the <code>~</code> operator, e.g. <code>let x = ~1;</code>. It could be dereferenced with the <code>*</code>
operator, and autoderef worked much like it does today.</p>

<p>As a &ldquo;primitive&rdquo; type; like all primitive types, <code>~T</code> was special. The compiler knew things about
it. The compiler knew how to dereference it without an explicit <code>Deref</code> impl. In fact, the <code>Deref</code>
traits <a href="https://github.com/rust-lang/rust/pull/12491">came into existence</a> much after <code>~T</code> did. <code>~T</code> never got an explicit <code>Deref</code> impl,
though it probably should have. This whole situation is reminiscent of how the <code>Add</code> impls on
integers work, the impl literally <a href="https://github.com/rust-lang/rust/blob/e57f061be20666eb0506f6f41551c798bbb38b60/src/libcore/ops.rs#L255">defines <code>Add</code> on two integers to be their addition</a>.
The reason these impls need to exist is so that people can still call <code>Add::add</code> if they need to
in generic code and be able to pass integers to things with an <code>Add</code> bound.</p>

<p>Eventually, there was a move to remove sigils from the language. The box constructor <code>~foo</code> was
superseded by <a href="https://github.com/rust-lang/rust/pull/11055/">placement <code>box</code> syntax</a>, which still exists in Rust nightly<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. Then, the
<a href="https://github.com/rust-lang/rust/pull/13904"><code>~T</code> type became <code>Box&lt;T&gt;</code></a>. (<code>~[T]</code> and <code>~str</code> would also be removed, though <code>~str</code> took
a very confusing detour with <code>StrBuf</code> first).</p>

<p>However, <code>Box&lt;T&gt;</code> was still special. It no longer needed special syntax to be referred to or
constructed, but it was still internally a special type. It didn&rsquo;t even have a <code>Deref</code> impl yet,
that came <a href="https://github.com/rust-lang/rust/pull/20052">six months later</a>, and it was implemented as <code>&amp;**self</code>, exactly the same
as it is today.</p>

<p>But why does it <em>have</em> to be special now? Rust had all the features it needed (allocations,
ownership, overloadable deref) to implement <code>Box&lt;T&gt;</code> in pure rust in the stdlib as if it
were a regular type.</p>

<p>Turns out that Rust didn&rsquo;t. You see, because <code>Box&lt;T&gt;</code> and before it <code>~T</code> were special, their
dereference semantics were implemented in a different part of the code. And, these semantics were
not the same as the ones for <code>DerefImm</code> and <code>DerefMut</code>, which were created for use with other smart
pointers. I don&rsquo;t know if the possibility of being used for <code>~T</code> was considered when
<code>DerefImm</code>/<code>DerefMut</code> were being implemented, or if it was a simple oversight, but <code>Box&lt;T&gt;</code> has
three pieces of behavior that could not be replicated in pure Rust at the time:</p>

<ul>
<li><code>box foo</code> in a pattern would destructure a box into its contents. It&rsquo;s somewhat the opposite of <code>ref</code></li>
<li><code>box foo()</code> performed placement box, so the result of <code>foo()</code> could be directly written to a preallocated box, reducing extraneous copies</li>
<li>You could <em>move out of deref</em> with <code>Box&lt;T&gt;</code></li>
</ul>


<p>The third one is the one that really gets to us here<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.
For a <em>regular</em> type, <code>*foo</code> will produce a temporary that must be immediately borrowed or copied.
You cannot do <code>let x = *y</code> for a non-<code>Copy</code> type. This dereference operation will call
<code>DerefMut::deref_mut</code> or <code>Deref::deref</code> based on how it gets borrowed. With <code>Box&lt;T&gt;</code>, you can do
this:</p>

<pre><code class="rust">let x = Box::new(vec![1,2,3,4]);
let y = *x; // moves the vec out into `y`, then deallocates the box
            // but does not call a destructor on the vec
</code></pre>

<p>For any other type, such an operation will produce a &ldquo;cannot move out of a borrow&rdquo; error.</p>

<p>This operation is colloquially called <code>DerefMove</code>, and there has been <a href="https://github.com/rust-lang/rfcs/pull/178/files?short_path=6f69a99#diff-6f69a990502a98c2eeb172d87269005d">an rfc</a> in the
past for making it into a trait. I suspect that the <code>DerefMove</code> semantics could even have been
removed from <code>Box&lt;T&gt;</code> before 1.0 (I don&rsquo;t find it <em>necessary</em>), but people had better things to do,
like fixing the million other rough edges of the language that can&rsquo;t be touched after backwards
compatibility is a thing.</p>

<p>So now we&rsquo;re stuck with it. The current status is that <code>Box&lt;T&gt;</code> is <em>still</em> a special type in the
compiler. By &ldquo;special type&rdquo; I don&rsquo;t just mean that the compiler treats it a bit differently (this is
true for any lang item), I mean that it literally is treated as
<a href="http://manishearth.github.io/rust-internals-docs/rustc/ty/enum.TypeVariants.html#TyBox.v">a completely new kind of type</a>, not as a struct the way it has been defined in liballoc.
There&rsquo;s a TON of cruft in the compiler related to this type, much of which can be removed, but some
of which can&rsquo;t. If we ever do get <code>DerefMove</code>, we should probably try removing it all again. After
writing this post I&rsquo;m half-convinced to try and implement an internal-use-only <code>DerefMove</code> and try
cleaning up the code myself.</p>

<p>Most of this isn&rsquo;t really useful to know unless you actually come across a case where you can make
use of <code>DerefMove</code> semantics, or if you work on the compiler. But it certainly is interesting!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Seriously though, does anyone use it much? I&rsquo;ve only seen it getting used for boxed DSTs (trait objects and boxed slices), which themselves are pretty rare, for sending heap types over FFI, and random special cases. I find this pretty interesting given that other languages are much more liberal with non-refcounted single-element allocation.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>It will probably eventually be replaced or made equivalent to the <code>&lt;-</code> syntax before stabilizing<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>It&rsquo;s easier to special case the first two, much like how <code>for</code> loops are aware of the iterator trait without the iterator trait being extremely special cased<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
