<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mozilla | In Pursuit of Laziness]]></title>
  <link href="http://manishearth.github.io/blog/categories/mozilla/atom.xml" rel="self"/>
  <link href="http://manishearth.github.io/"/>
  <updated>2017-05-14T20:10:04+00:00</updated>
  <id>http://manishearth.github.io/</id>
  <author>
    <name><![CDATA[Manish Goregaokar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prolonging Temporaries in Rust]]></title>
    <link href="http://manishearth.github.io/blog/2017/04/13/prolonging-temporaries-in-rust/"/>
    <updated>2017-04-13T18:36:05+00:00</updated>
    <id>http://manishearth.github.io/blog/2017/04/13/prolonging-temporaries-in-rust</id>
    <content type="html"><![CDATA[<p>A colleague of mine learning Rust had an interesting type / borrow checker error. The solution needs
a less-used feature of Rust (which basically exists precisely for this kind of thing), so I thought
I&rsquo;d document it.</p>

<p>The code was like this:</p>

<pre><code class="rust">let maybe_foo = if some_condition {
    thing.get_ref() // returns Option&lt;&amp;Foo&gt;, borrowed from `thing`
} else {
    thing.get_owned() // returns Option&lt;Foo&gt;
};

use(maybe_foo);
</code></pre>

<p>If you want to follow along, here is a full program that does this (<a href="https://play.rust-lang.org/?gist=e09a79b511e347fe786e4689d282b806&amp;version=stable&amp;backtrace=0">playpen</a>):</p>

<pre><code class="rust">#[derive(Debug)]
struct Foo;

struct Thingy {
    foo: Foo
}

impl Thingy {
    pub fn get_ref(&amp;self) -&gt; Option&lt;&amp;Foo&gt; {
        Some(&amp;self.foo)
    }
    pub fn get_owned(&amp;self) -&gt; Option&lt;Foo&gt; {
        Some(Foo)
    }
    pub fn new() -&gt; Self {
        Thingy {
            foo: Foo
        }
    }
}



pub fn main() {
    let some_condition = true;
    let thing = Thingy::new();

    let maybe_foo = if some_condition {
        thing.get_ref() // returns Option&lt;&amp;Foo&gt;, borrowed from `thing`
    } else {
        thing.get_owned() // returns Option&lt;Foo&gt;
    };

    println!("{:?}", maybe_foo);
}
</code></pre>

<p>I&rsquo;m only going to be changing the contents of <code>main()</code> here.</p>

<p>What&rsquo;s happening here is that a non-<code>Copy</code> type, <code>Foo</code>, is returned in an <code>Option</code>. In one case,
we have a reference to the <code>Foo</code>, and in another case an owned copy.</p>

<p>We want to set a variable to these, but of course we can&rsquo;t because they&rsquo;re different types.</p>

<p>In one case, we have an owned <code>Foo</code>, and we can usually obtain a borrow from an owned type. For
<code>Option</code>, there&rsquo;s a convenience method <code>.as_ref()</code> that does this<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Let&rsquo;s try using that (<a href="https://play.rust-lang.org/?gist=41c3f836b9485c216ccb05c257ae5326&amp;version=stable&amp;backtrace=0">playpen</a>):</p>

<pre><code class="rust">let maybe_foo = if some_condition {
    thing.get_ref()
} else {
    thing.get_owned().as_ref()
};
</code></pre>

<p>This will give us an error.</p>

<pre><code>error: borrowed value does not live long enough
  --&gt; &lt;anon&gt;:32:5
   |
31 |         thing.get_owned().as_ref()
   |         ----------------- temporary value created here
32 |     };
   |     ^ temporary value dropped here while still borrowed
...
35 | }
   | - temporary value needs to live until here

error: aborting due to previous error
</code></pre>

<p>The problem is, <code>thing.get_owned()</code> returns an owned value. There&rsquo;s nothing that it gets anchored to
(we don&rsquo;t set its value to a variable), so it is just a temporary &ndash; we can call methods on it, but
once we&rsquo;re done the value will go out of scope.</p>

<p>What we want is something like</p>

<pre><code class="rust">let maybe_foo = if some_condition {
    thing.get_ref()
} else {
    let owned = thing.get_owned();
    owned.as_ref()
};
</code></pre>

<p>but this will still give a borrow error &ndash; <code>owned</code> will still go out of scope within the <code>if</code> block,
and we need the reference to it last as long as <code>maybe_foo</code> (outside the block) is supposed to last.</p>

<p>So this is no good.</p>

<p>An alternate solution here <em>can</em> be copying/cloning the <code>Foo</code> in the <em>first</em> case by calling <code>.map(|x|
x.clone())</code> or <code>.cloned()</code> or something. Sometimes you don&rsquo;t want to clone, so this isn&rsquo;t great.</p>

<p>Another solution here &ndash; the generic advice for dealing with values which may be owned or borrow &ndash;
is to use <code>Cow</code>. It does incur a runtime check, though; one which can be optimized out if things are
inlined enough.</p>

<p>What we need to do here is to extend the lifetime of the temporary returned by <code>thing.get_owned()</code>.
We need to extend it <em>past</em> the scope of the <code>if</code>.</p>

<p>One way to do this is to have an <code>Option</code> outside that scope which we mutate (<a href="https://play.rust-lang.org/?gist=7868045f2cebec6d23e7a065f5823767&amp;version=stable&amp;backtrace=0">playpen</a>).</p>

<pre><code class="rust">let mut owned = None;
let maybe_foo = if some_condition {
    thing.get_ref()
} else {
    owned = thing.get_owned();
    owned.as_ref()
};
</code></pre>

<p>This works in this case, but in this case we already had an <code>Option</code>. If <code>get_ref()</code> and <code>get_owned()</code>
returned <code>&amp;Foo</code> and <code>Foo</code> respectively, then we&rsquo;d need to do something like:</p>

<pre><code class="rust">let mut owned = None;
let maybe_foo = if some_condition {
    thing.get_ref()
} else {
    owned = Some(thing.get_owned());
    owned.as_ref().unwrap()
};
</code></pre>

<p>which is icky since it introduces an unwrap.</p>

<p>What we really need is a way to signal to the compiler that it needs to hold on to that temporary
for the scope of the enclosing block.</p>

<p>We can do that! (<a href="https://play.rust-lang.org/?gist=1ddf2a428e73b01baa72acdad7cbbf2b&amp;version=stable&amp;backtrace=0">playpen</a>)</p>

<pre><code class="rust">let owned; // ðŸ˜¯ðŸ˜¯ðŸ˜¯ðŸ˜¯ðŸ˜¯
let maybe_foo = if some_condition {
    thing.get_ref()
} else {
    owned = thing.get_owned();
    owned.as_ref()
};
</code></pre>

<p>We know that Rust doesn&rsquo;t do &ldquo;uninitialized&rdquo; variables. If you want to name a variable, you have to
initialize it. <code>let foo;</code> feels rather like magic in this context, because it looks like we&rsquo;ve declared
an uninitialized variable.</p>

<p>What&rsquo;s less well known is that Rust <em>can</em> do &ldquo;deferred&rdquo; initialization. Here, you declare a variable
and can initialize it later, but expressions involving the variable can only exist in branches
where the compiler knows it has been initialized.</p>

<p>This is the case here. We declared the <code>owned</code> variable beforehand. It now lives in the outer scope
and won&rsquo;t be destroyed until the end of the outer scope. However, the variable cannot be used directly
in an expression in the first branch, or after the <code>if</code>. Doing so will give a compile time error
saying <code>use of possibly uninitialized variable: `owned`</code>. We can only use it in the <code>else</code> branch
because the compiler can see that it is unconditionally initialized in that branch.</p>

<p>We can still read the value of <code>owned</code> indirectly through <code>maybe_foo</code> from outside the branch.
This is okay because the storage of <code>owned</code> is guaranteed to live as long as the outer scope,
and <code>maybe_foo</code> borrows from it. The only time <code>maybe_foo</code> is set to a value inside <code>owned</code> is when
<code>owned</code> has been initialized, so it is safe.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In my experience <code>.as_ref()</code> is the solution to many, many borrow check issues newcomers come across, especially those involving <code>.map()</code><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You're Doing It Wrong]]></title>
    <link href="http://manishearth.github.io/blog/2017/04/05/youre-doing-it-wrong/"/>
    <updated>2017-04-05T16:37:40+00:00</updated>
    <id>http://manishearth.github.io/blog/2017/04/05/youre-doing-it-wrong</id>
    <content type="html"><![CDATA[<p>&ldquo;You&rsquo;re doing it wrong&rdquo;</p>

<p>A common refrain in issue trackers and discussion forums everywhere. In isolation,
it&rsquo;s a variant of RTFM &ndash; give a non-answer when someone wants help, and bounce them
back to a manual or docs which they probably have already read. Not very helpful,
and not useful to anyone. Of course, one can accompany it with a nice explanation
of how to do it right; &ldquo;You&rsquo;re doing it wrong&rdquo; isn&rsquo;t always a bad thing :)</p>

<p>Especially when it comes to programming languages, but in general in the context of any programming
tool or library, &ldquo;you&rsquo;re doing it wrong&rdquo; is almost always due to a &ldquo;bad&rdquo; mental model. The person, whilst
learning, has built a mental model of how the tool works, but this doesn&rsquo;t accurately reflect
reality. Other times, it does reflect reality, but it does not reflect the mental model of the
maintainers (there can be multiple valid ways of looking at something!),
which leads to an impedance mismatch when reading docs or error messages.</p>

<p>In other cases, &ldquo;doing it wrong&rdquo; is a <a href="https://meta.stackexchange.com/q/66377/178438">case of the XY problem</a>, where the user has problem X,
and think they can solve it with solution Y, and end up asking how they can achieve Y. This happens pretty
often &mdash; folks may be approaching your technology with prior experience with related things
that work differently, and may think the same idioms apply.</p>

<p>When I was at <a href="https://maintainerati.org/">WONTFIX</a>, someone who had done support work in the past mentioned that one
thing everyone learns in support is <strong>&ldquo;the user is always wrong &hellip;. and it&rsquo;s not their fault!&rdquo;</strong>.</p>

<p>This is a pretty good template for an attitude to approach &ldquo;doing it wrong&rdquo; questions about your
technology on online forums as well. And this doesn&rsquo;t just benefit the users who ask questions,
this attitude can benefit your technology!</p>

<p>Back when I used to be more active contributing to the Rust compiler, I also used to hang out in
<code>#rust</code> a lot, and often answer newbie questions (now <code>#rust-beginners</code> exists too, and I hang out
in both, but I don&rsquo;t really actively participate as much). One thing I learned to do was probe
deeper into why people hit that confusion in the first place. It&rsquo;s almost always a &ldquo;bad&rdquo; mental
model. Rust is rarely the first programming language folks learn, and people approach it with
preconceptions about how programming works. This isn&rsquo;t unique to Rust, this happens any time someone
learns a language with a different paradigm &mdash; learning C or C++ after doing a GCd language,
learning a functional language after an imperative one, statically typed after dynamic, or one of
the many other axes by which programming languages differ.</p>

<p>Other times, it&rsquo;s just assumptions they made when reading between the lines of whatever resource
they used to learn the language.</p>

<p>So, anyway, folks often have a &ldquo;bad&rdquo; mental model. If we are able to identify that model and correct
it, we have saved that person from potentially getting confused at every step in the future. Great!</p>

<p>With a <em>tiny</em> bit more effort, however, we can do one step better. Not for that person, but for
ourselves! We can probe a bit more and try to understand what caused them to obtain that mental
model. And fix the docs so that it never happens again! Of course, not everyone reads the docs, but
that&rsquo;s what diagnostics are for (in the case of errors). They&rsquo;re a tool to help us nudge the user
towards the right mental model, whilst helping them fix their immediate problem. Rust has for a long
time had pretty great diagnostics, with improvements happening all the time<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I think this is at
least in part due to the attitude of the folks in <code>#rust</code>; always trying to figure out how to
preempt various confusions they see.</p>

<p>It&rsquo;s a good attitude to have. I hope more folks, both in and out of the Rust community, approach
&ldquo;You&rsquo;re doing it wrong&rdquo; cases like that.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Diagnostics issues are often the easiest way to contribute to the compiler itself, so if you want to contribute, I suggest starting there. Willing to mentor!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I Never Hear the Phrase 'INHTPAMA' Anymore]]></title>
    <link href="http://manishearth.github.io/blog/2017/03/19/inhtpinhtpamaa/"/>
    <updated>2017-03-19T02:50:42+00:00</updated>
    <id>http://manishearth.github.io/blog/2017/03/19/inhtpinhtpamaa</id>
    <content type="html"><![CDATA[<p>Imagine never hearing the phrase &lsquo;INHTPAMA&rsquo; again.</p>

<p>Oh, that&rsquo;s already the case? Bummer.</p>

<p>Often, when talking about Rust, folks refer to the core aliasing rule as &ldquo;that <code>&amp;mut</code> thing&rdquo;,
&ldquo;compile-time <code>RWLock</code>&rdquo; (or &ldquo;compile-time <code>RefCell</code>&rdquo;), or something similar. Basically, referring to
the fact that you can&rsquo;t mutate the data that is currently held via an <code>&amp;</code> reference, and that you
can&rsquo;t mutate or read the data currently held via an <code>&amp;mut</code> reference except through that reference
itself.</p>

<p>It&rsquo;s always bugged me that we really don&rsquo;t have a name for this thing. It&rsquo;s one of the core
bits of Rust, and crops up often in discussions.</p>

<p>But we did have a name for it! It was &ldquo;INHTPAMA&rdquo; (which was later butchered into &ldquo;INHTWAMA&rdquo;).</p>

<p>This is a reference to <a href="http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/">Niko&rsquo;s 2012 blog post</a>, titled
&ldquo;Imagine Never Hearing The Phrase &lsquo;aliasable, mutable&rsquo; again&rdquo;. It&rsquo;s where the aliasing
rules came from. Go read it, it&rsquo;s great. It talks about this weird language with at symbols
and purity, but I assure you, that language is Baby Rust. Or maybe Teenage Rust. The
<a href="https://www.ars.usda.gov/images/docs/9910_10104/Pg-lifecycle.jpg">lifecycle of rusts is complex and interesting</a> and I don&rsquo;t know how to categorize it.</p>

<p>The point of this post isn&rsquo;t really to encourage reviving the use of &ldquo;INHTWAMA&rdquo;; it&rsquo;s
a rather weird acronym that will probably confuse folks. I would like to have a better
way of refering to &ldquo;that <code>&amp;mut</code> thing&rdquo;, but I&rsquo;d prefer if it wasn&rsquo;t a confusing acronym
that carries no meaning of its own if you don&rsquo;t know the history of it. That&rsquo;s a recipe for
making new community members feel like outsiders.</p>

<p>But that post is amazing and I&rsquo;d hate to see it drop out of the collective
memory of the Rust community.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Are Sum, Product, and Pi Types?]]></title>
    <link href="http://manishearth.github.io/blog/2017/03/05/what-are-sum-product-and-pi-types/"/>
    <updated>2017-03-05T02:52:00+00:00</updated>
    <id>http://manishearth.github.io/blog/2017/03/05/what-are-sum-product-and-pi-types</id>
    <content type="html"><![CDATA[<p><em>See also: <a href="https://tonyarcieri.com/a-quick-tour-of-rusts-type-system-part-1-sum-types-a-k-a-tagged-unions">Tony&rsquo;s post on the same topic</a></em></p>

<p>You often hear people saying &ldquo;Language X<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> has sum types&rdquo; or &ldquo;I wish language X had sum types&rdquo;<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>,
or &ldquo;Sum types are cool&rdquo;.</p>

<p>Much like fezzes and bow ties, sum types are indeed cool.</p>

<p><img class="center" src="/images/post/memes/sum-types-are-cool.jpg" width="400"></p>

<p>These days, I&rsquo;ve also seen people asking about &ldquo;Pi types&rdquo;, because of <a href="https://github.com/ticki/rfcs/blob/pi-types-2/text/0000-pi-types.md">this Rust RFC</a>.</p>

<p>But what does &ldquo;sum type&rdquo; mean? And why is it called that? And what, in the name of sanity, is
a Pi type?</p>

<p>Before I start, I&rsquo;ll mention that while I will be covering some type theory to explain the names
&ldquo;sum&rdquo; and &ldquo;product&rdquo;, you don&rsquo;t need to understand these names to use these things! Far too often
do people have trouble understanding relatively straightforward concepts in languages because
they have confusing names with confusing mathematical backgrounds<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<h2>So what&rsquo;s a sum type? (the no-type-theory version)</h2>

<p>In it&rsquo;s essence, a sum type is basically an &ldquo;or&rdquo; type. Let&rsquo;s first look at structs.</p>

<pre><code class="rust">struct Foo {
    x: bool,
    y: String,
}
</code></pre>

<p><code>Foo</code> is a <code>bool</code> AND a <code>String</code>. You need one of each to make one.
This is an &ldquo;and&rdquo; type, or a &ldquo;product&rdquo; type (I&rsquo;ll explain the name later).</p>

<p>So what would an &ldquo;or&rdquo; type be? It would be one where the value can be a
<code>bool</code> OR a <code>String</code>. You can achieve this with C++ with a union:</p>

<pre><code class="cpp">union Foo {
    bool x;
    string y;
}

foo.x = true; // set it to a bool
foo.y = "blah"; // set it to a string
</code></pre>

<p>However, this isn&rsquo;t <em>exactly</em> right, since the value doesn&rsquo;t store the information
of which variant it is. You could store <code>false</code> and the reader wouldn&rsquo;t know
if you had stored an empty <code>string</code> or a <code>false</code> <code>bool</code>.</p>

<p>There&rsquo;s a pattern called &ldquo;tagged union&rdquo; (or &ldquo;discriminated union&rdquo;) in C++ which bridges this gap.</p>

<pre><code class="cpp">union FooUnion {
    bool x;
    string y;
}

enum FooTag {
    BOOL, STRING
}

struct Foo {
    FooUnion data;
    FooTag tag;
}

// set it to a bool
foo.data.x = true;
foo.tag = BOOL;

// set it to a string
foo.data.y = "blah";
foo.tag = STRING;
</code></pre>

<p>Here, you manually set the tag when setting the value. C++ also has <code>std::variant</code> (or
<code>boost::variant</code>) that encapsulates this pattern with a better API.</p>

<p>While I&rsquo;m calling these &ldquo;or&rdquo; types here, the technical term for such types is &ldquo;sum&rdquo; types.
Other languages have built-in sum types.</p>

<p>Rust has them and calls them &ldquo;enums&rdquo;. These are a more generalized version of the
enums you see in other languages.</p>

<pre><code class="rust">enum Foo {
    Str(String),
    Bool(bool)
}

let foo = Foo::Bool(true);

// "pattern matching"
match foo {
    Str(s) =&gt; /* do something with string `s` */,
    Bool(b) =&gt; /* do something with bool `b` */,
}
</code></pre>

<p>Swift is similar, and also calls them enums
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">str</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">boolean</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">.</span><span class="n">boolean</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span><span class='line'><span class="k">switch</span> <span class="n">foo</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="k">let</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>        <span class="c1">// do something with string &lt;code&gt;s&lt;/code&gt;</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">boolean</span><span class="p">(</span><span class="k">let</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>        <span class="c1">// do something with boolean &lt;code&gt;b&lt;/code&gt;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>You can fake these in Go using interfaces, as well. Typescript has built-in
unions which can be typechecked without any special effort, but you need
to add a tag (like in C++) to pattern match on them.</p>

<p>Of course, Haskell has them:</p>

<pre><code class="haskell">data Foo = B Bool | S String

-- define a function
doThing :: Foo -&gt; SomeReturnType
doThing (B b) = -- do something with boolean b
doThing (S s) = -- do something with string s

-- call it
doThing (S "blah")
doThing (B True)
</code></pre>

<p>One of the very common things that languages with sum types do is express nullability
as a sum type;</p>

<pre><code class="rust">// an Option is either "something", containing a type, or "nothing"
enum Option&lt;T&gt; {
    Some(T),
    None
}

let x = Some("hello");
match x {
    Some(s) =&gt; println!("{}", s),
    None =&gt; println!("no string for you"),
}
</code></pre>

<p>Generally, these languages have &ldquo;pattern matching&rdquo;, which is like a <code>switch</code>
statement on steroids. It lets you match on and destructure all kinds of things,
sum types being one of them. Usually, these are &ldquo;exhaustive&rdquo;, which means that
you are forced to handle all possible cases. In Rust, if you remove that <code>None</code>
branch, the program won&rsquo;t compile. So you&rsquo;re forced to deal with the none case,
<em>somehow</em>.</p>

<p>In general sum types are a pretty neat and powerful tool. Languages with them built-in
tend to make heavy use of them, almost as much as they use structs.</p>

<h2>Why do we call it a sum type?</h2>

<p><em>Here be (type theory) <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">dragons</a></em></p>

<p>Let&rsquo;s step back a bit and figure out what a type is.</p>

<p>It&rsquo;s really a restriction on the values allowed. It can have things like methods and whatnot
dangling off it, but that&rsquo;s not so important here.</p>

<p></p>

<p>In other words, it&rsquo;s like<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">set</a>. A boolean is the set &#92;(\{\mathtt{true}, \mathtt{false}\}&#92;). An 8-bit unsigned integer
(<code>u8</code> in Rust) is the set &#92;(\{0, 1, 2, 3, &hellip;. 254, 255\}&#92;). A string is a set with
infinite elements, containing all possible valid strings<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<p>What&rsquo;s a struct? A struct with two fields contains every possible combination of elements from the two sets.</p>

<pre><code class="rust">struct Foo {
    x: bool,
    y: u8,
}
</code></pre>

<p>The set of possible values of <code>Foo</code> is</p>

<p>&#92;[\{(\mathtt{x}, \mathtt{y}): \mathtt{x} \in \mathtt{bool}, \mathtt y \in \mathtt{u8}\}&#92;]</p>

<p>(Read as &ldquo;The set of all &#92;((\mathtt{x}, \mathtt{y})&#92;) where &#92;(\tt x&#92;) is in &#92;(\mathtt{bool}&#92;) and &#92;(\tt y&#92;) is in &#92;(\mathtt{u8}&#92;)&rdquo;)</p>

<p>This is called a <em>Cartesian product</em>, and is often represented as &#92;(\tt Foo = bool \times u8&#92;).
An easy way to view this as a product is to count the possible values: The number of possible values
of <code>Foo</code> is the number of possible values of <code>bool</code> (2) <em>times</em> the number of possible values of <code>u8</code> (256).</p>

<p>A general struct would be a &ldquo;product&rdquo; of the types of each field, so something like</p>

<pre><code class="rust">struct Bar {
    x: bool,
    y: u8,
    z: bool,
    w: String
}
</code></pre>

<p>is &#92;(\mathtt{Bar = bool \times u8 \times bool \times String}&#92;)</p>

<p>This is why structs are called &ldquo;product types&rdquo;<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>.</p>

<p>You can probably guess what comes next &ndash; Rust/Swift enums are &ldquo;sum types&rdquo;, because they are the
<em>sum</em> of the two sets.</p>

<pre><code class="rust">enum Foo {
    Bool(bool),
    Integer(u8),
}
</code></pre>

<p>is a set of all values which are valid booleans, <em>and</em> all values which are valid integers. This
is a sum of sets, &#92;(\tt Foo = bool + u8&#92;). More accurately, it&rsquo;s a <em>disjoint union</em>, where if the input
sets have overlap, the overlap is &ldquo;discriminated&rdquo; out.</p>

<p>An example of this being a disjoint union is:</p>

<pre><code class="rust">enum Bar {
    Bool1(bool),
    Bool2(bool),
    Integer(u8).
}
</code></pre>

<p>This is not &#92;(\tt Bar = bool + bool + u8&#92;), because &#92;(\tt bool + bool = bool&#92;), (regular set addition doesn&rsquo;t duplicate the overlap).</p>

<p>Instead, it&rsquo;s something like</p>

<p>&#92;[\tt Bar = bool + otherbool + u8&#92;]</p>

<p>where &#92;(\tt otherbool&#92;) is also a set &#92;(\tt \{true, false\}&#92;),
except that these elements are <em>different</em> from those in &#92;(\tt bool&#92;). You can look at it as if</p>

<p>&#92;[\tt otherbool = \{true_2, false_2\}&#92;]</p>

<p>so that</p>

<p>&#92;[\mathtt{bool + otherbool} = \{\mathtt{true, false, true_2, false_2}\}&#92;]</p>

<p>For sum types, the number of possible values is the sum of the number of possible values of
each of its component types.</p>

<p>So, Rust/Swift enums are &ldquo;sum types&rdquo;.</p>

<p>You may often notice the terminology &ldquo;algebraic datatypes&rdquo; (ADT) being used, usually that&rsquo;s just
talking about sum and product types together &ndash; a language with ADTs will have both.</p>

<p>In fact, you can even have <em>exponential</em> types! The notation A<sup>B</sup> in set theory does mean something,
it&rsquo;s the set of all possible mappings from &#92;(B&#92;) to &#92;(A&#92;). The number of elements is &#92;(N_A^{N_B}&#92;). So
basically, the type of a function (which is a mapping) is an &ldquo;exponential&rdquo; type. You can also view it as
an iterated product type, a function from type <code>B</code> to <code>A</code> is really a struct like this:</p>

<pre><code class="rust">// the type
fn my_func(b: B) -&gt; A;

// is conceptually (each possible my_func can be written as an instance of)

struct my_func {
    b1: A, // value for first element in B
    b2: A, // value for second element in B
    b3: A,
    // ... 
}
</code></pre>

<p>given a value of the input <code>b</code>, the function will find the right field of <code>my_func</code> and return
the mapping. Since a struct is a product type, this is</p>

<p>&#92;[\mathtt{A}^{N_\mathtt{B}} = \tt A \times A \times A \times \dots&#92;]</p>

<p>making it an exponential type.</p>

<p><a href="http://strictlypositive.org/diff.pdf">You can even take <em>derivatives</em> of types!</a> (h/t Sam Tobin-Hochstadt for pointing this out to me)</p>

<p></p>

<h2>What, in the name of sanity, is a Pi type?</h2>

<p><img class="center" src="/images/post/memes/what-in-the-name-of-sanity.jpg" width="400"></p>

<p>It&rsquo;s essentially a form of dependent type. A dependent type is when your type
can depend on a value. An example of this is integer generics, where you
can do things like <code>Array&lt;bool, 5&gt;</code>, or <code>template&lt;unsigned int N, typename T&gt; Array&lt;T, N&gt; ...</code> (in C++).</p>

<p>Note that the type signature contains a <em>type</em> dependent on an integer, being generic over multiple
different array lengths.</p>

<p>The name comes from how a constructor for these types would look:</p>

<pre><code class="rust">// create an array of booleans from a given integer
// I made up this syntax, this is _not_ from the Rust Pi type RFC
fn make_array(x: u8) -&gt; Array&lt;bool, x&gt; {
    // ...
}

// or
// (the proposed rust syntax)
fn make_array&lt;const x: u8&gt;() -&gt; Array&lt;bool, x&gt; {
   // ... 
}
</code></pre>

<p>What&rsquo;s the type of <code>make_array</code> here? It&rsquo;s a function which can accept any integer
and return a different type in each case. You can view it as a set of functions,
where each function corresponds to a different integer input. It&rsquo;s basically:</p>

<pre><code class="rust">struct make_array {
    make_array_0: fn() -&gt; Array&lt;bool, 0&gt;,
    make_array_1: fn() -&gt; Array&lt;bool, 1&gt;,
    make_array_2: fn() -&gt; Array&lt;bool, 2&gt;,
    make_array_3: fn() -&gt; Array&lt;bool, 3&gt;,
    make_array_4: fn() -&gt; Array&lt;bool, 4&gt;,
    make_array_5: fn() -&gt; Array&lt;bool, 5&gt;,
    // ... 
}
</code></pre>

<p>Given an input, the function chooses the right child function here, and calls it.</p>

<p></p>

<p>This is a struct, or a product type! But it&rsquo;s a product of an infinite number of types<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>.</p>

<p>We can look at it as</p>

<p>&#92;[\texttt{make_array} = \prod\limits_{x = 0}^\infty\left( \texttt{fn()} \mathtt\to \texttt{Array&lt;bool, x&gt;}\right)&#92;]</p>

<p>The usage of the &#92;(\Pi&#92;) symbol to denote an iterative product gives this the name &ldquo;Pi type&rdquo;.</p>

<p>In languages with lazy evaluation (like Haskell), there is no difference between having a function
that can give you a value, and actually having the value. So, the type of <code>make_array</code> is the type
of <code>Array&lt;bool, N&gt;</code> itself in languages with lazy evaluation.</p>

<p>There&rsquo;s also a notion of a &ldquo;sigma&rdquo; type, which is basically</p>

<p>&#92;[\sum\limits_{x = 0}^\infty \left(\texttt{fn()} \mathtt\to \texttt{Array&lt;bool, x&gt;}\right)&#92;]</p>

<p>With the Pi type, we had &ldquo;for all N we can
construct an array&rdquo;, with the sigma type we have &ldquo;there exists some N for which we can construct this array&rdquo;.
As you can expect, this type can be expressed with a possibly-infinite enum, and instances of this type
are basically instances of <code>Array&lt;bool, N&gt;</code> for some specific <code>N</code> where the <code>N</code> is only known at runtime.
(much like how regular sum types are instances of one amongst multiple types, where the exact type
is only known at runtime). <code>Vec&lt;bool&gt;</code> is conceptually similar to the sigma type <code>Array&lt;bool, ?&gt;</code>,
as is <code>&amp;[bool]</code>.</p>

<p></p>

<h2>Wrapping up</h2>

<p>Types are sets, and we can do set-theory things on them to make cooler types.</p>

<p>Let&rsquo;s try to avoid using confusing terminology, however. If Rust <em>does</em> get &ldquo;pi types&rdquo;,
let&rsquo;s just call them &ldquo;dependent types&rdquo; or &ldquo;const generics&rdquo; :)</p>

<p><em>Thanks to Zaki, Avi Weinstock, Corey Richardson, and Peter Atashian for reviewing drafts of this post.</em></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Rust, Swift, <em>sort of</em> Typescript, and all the functional languages who had it before it was cool.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Lookin&#8217; at you, Go.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Moooooooooooooooonads<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Types are not exactly sets due to some differences, but for the purposes of this post we can think of them like sets.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Though you can argue that strings often have their length bounded by the pointer size of the platform, so it&rsquo;s still a finite set.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>This even holds for zero-sized types, for more examples, check out <a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">this blog post</a><a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>Like with strings, in practice this would probably be bounded by the integer type chosen<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mitigating Underhandedness: Fuzzing Your Code]]></title>
    <link href="http://manishearth.github.io/blog/2017/03/03/mitigating-underhandedness-fuzzing-your-code/"/>
    <updated>2017-03-03T00:13:54+00:00</updated>
    <id>http://manishearth.github.io/blog/2017/03/03/mitigating-underhandedness-fuzzing-your-code</id>
    <content type="html"><![CDATA[<p><em>This may be part of a collaborative blog post series about underhanded Rust code. Or it may not. I invite you to write your own posts about underhanded code to make it so!</em></p>

<p>The <a href="https://underhanded.rs/blog/2017/02/28/extending-submission-deadline.en-US.html">submission deadline for the Underhanded Rust competition has been extended</a>, so
let&rsquo;s talk more about how to keep your code working and free from bugs/underhandedness!</p>

<p><a href="http://manishearth.github.io/blog/2017/01/21/mitigating-underhandedness-clippy/">Previously, we talked about Clippy</a>.</p>

<p>Now, really, underhanded bugs are just another form of bug. And how do we find bugs? We test!</p>

<p>We write unit tests. We run the code under Valgrind, ASan, MSan, UBSan, TSan, and any other sanitizer
we can get our hands on. Tests tests tests. More tests. Tests.</p>

<p>But, there&rsquo;s a problem here. You need to write <em>test cases</em> to make this work. These are inputs
fed to your code after which you check whatever invariants your code has. There&rsquo;s
no guarantee that the test cases you write will exercise all the code paths in your
program. This applies for sanitizers too, sanitizers are limited to testing the code paths
that your test cases hit.</p>

<p>Of course, you can use code coverage tools to ensure that all these code paths will be hit.
However, there&rsquo;s a conflict here &ndash; your code will have many code paths that are
<em>not supposed to be hit ever</em>. Things like redundant bounds checks, null checks, etc.
In Rust programs such code paths generally use panics.</p>

<p>Now, these code paths are never <em>supposed</em> to be hit, so they&rsquo;ll never show up in your
code coverage. But you don&rsquo;t have a guarantee that they can never be hit, short
of formally verifying your program. The only solution here is writing more test cases.</p>

<p>Aside from that, even ignoring those code paths, you still need to manually write
test cases for everything. For each possible code path in your code, if you want to
be sure.</p>

<p>Who wants to manually write a million test cases?</p>

<p><img class="center" src="/images/post/memes/aint-nobody.jpg" width="400"></p>

<p><img class="center" src="/images/post/memes/that-would-be-great.jpg" width="400"></p>

<p>Enter fuzzing. What fuzzing will do is feed your program random inputs, carefully watching the
codepaths being taken, and try to massage the inputs so that new, interesting (usually crashy)
codepaths are taken. You write tests for the fuzzer such that they can accept arbitrary input, and
the fuzzer will find cases where they crash or panic.</p>

<p>One of the most popular fuzzers out there is <a href="http://lcamtuf.coredump.cx/afl/">AFL</a>, which takes a binary and feeds it random
input. Rust <a href="https://github.com/rust-fuzz/afl.rs">has a library that you can use for running AFL</a>, however it currently needs
to be run via a Docker image or needs a recompilation of rustc, since it adds a custom LLVM pass.
We&rsquo;re working on making this step unnecessary.</p>

<p>However, as of a few weeks ago, we now have bindings for <a href="http://llvm.org/docs/LibFuzzer.html">libFuzzer</a>, which uses existing
instrumentation options built in to LLVM itself! libFuzzer works a bit differently; instead
of giving it a binary, you write a function in a special way and give it a library containing
that function, which it turns into a fuzzer binary. This is faster, since the fuzzer lives
inside the binary itself and it doesn&rsquo;t need to execute a new program each time.</p>

<p>Using libFuzzer in Rust is easy. Install <a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a>:</p>

<pre><code class="sh">$ cargo install cargo-fuzz
</code></pre>

<p>Now, within your crate, initialize the fuzz setup:</p>

<pre><code class="sh">$ cargo fuzz init
</code></pre>

<p>This will create a fuzzing crate in <code>fuzz/</code>, with a single &ldquo;fuzz target&rdquo;, <code>fuzzer_script_1</code>.
You can add more such targets with <code>cargo fuzz add name_of_target</code>. Fuzz targets are small libraries
with a single function in them; the function that will be called over and over again by the fuzzer.
It is up to you to fill in the body of this function, such that the program will crash or panic
if and only if something goes wrong.</p>

<p>For example, for the <code>unicode-segmentation</code> crate, <a href="https://github.com/Manishearth/unicode-segmentation/blob/99b3636ef6b4d96c05644403c1c2eccba2c5f5db/fuzz/fuzzers/equality.rs">one of the fuzz targets I wrote</a> just
takes the string, splits it by grapheme and word boundaries, recombines it, and then asserts that
the new string is the same.</p>

<pre><code class="rust">pub extern fn go(data: &amp;[u8]) {
    // we only deal with unicode input
    // bail early, *without panicking* if the input isn't utf8
    if let Ok(s) = str::from_utf8(data) {
        // split into graphemes, recollect
        let result = UnicodeSegmentation::graphemes(s, true).flat_map(|s| s.chars()).collect::&lt;String&gt;();
        // recollected string should be the same as the input, panic if not
        assert_eq!(s, result);

        // split into words, recollect
        let result = s.split_word_bounds().flat_map(|s| s.chars()).collect::&lt;String&gt;();
        // recollected string should be the same as the input, panic if not
        assert_eq!(s, result);
    }
}
</code></pre>

<p>The other targets ensure that the forward and reverse word/grapheme
iterators produce the same results. They all take the byte slice input, attempt to convert to UTF8
(silently failing  &ndash; NOT panicking &ndash; if not possible), and then use the string as an input
testcase.</p>

<p>Now, these targets will panic if the test fails, and the fuzzer will try and force that panic to
happen. But also, these targets put together exercise most of the API surface of the crate, so
the fuzzer may also find panics (or even segmentation faults!) in the crate itself. For example,
the <a href="https://github.com/servo/rust-url/blob/3e5541e51e02d8acb10a6ea8ab174ba1bc23ce41/fuzz/fuzzers/parse.rs#L10">fuzz target for rust-url</a> doesn&rsquo;t itself assert; all it does is try to parse the given
string. The fuzzer will try to get the URL parser to panic.</p>

<p>To run a fuzz script:</p>

<pre><code class="sh">$ cargo fuzz run fuzzer_script_1
</code></pre>

<p>This will start the fuzzer, running until it finds a crash or panic. It may also
find other things like inputs which make the code abnormally slow.</p>

<p>Fuzzing can find some interesting bugs. For example, the unicode-segmentation
fuzzers found <a href="https://github.com/unicode-rs/unicode-segmentation/issues/19">this bug</a>, where an emoji followed by <em>two</em> skin tone modifiers
isn&rsquo;t handled correctly. We&rsquo;d probably never have been able to come up with this testcase on our
own. But the fuzzer could find it!</p>

<p>The Rust Cap&#8217;n Proto crate ran cargo-fuzz and found <a href="https://dwrensha.github.io/capnproto-rust/2017/02/27/cargo-fuzz.html">a whole ton of bugs</a>. There
are more such examples <a href="https://github.com/rust-fuzz/cargo-fuzz#trophy-case">in the trophy case</a> (be sure to add any of your own findings
to the trophy case, too!)</p>

<p>cargo-fuzz is relatively new, so the API and behavior may still be tweaked a bit before 1.0.
But you can start taking it for a spin now, and finding bugs!</p>
]]></content>
  </entry>
  
</feed>
